Agent Changes / Reviews

code/code.md:50:5:     Trailing whitespace
code/code.txt:7:8:     delete trailing whitespace
code/code.txt:58:2:    trailing
code/code.txt:100:2:   trailing whitespace
code/code.txt:173:32:  tidy - check files for leading/trailing whitespace at ends of file
code/style2.txt:9:2:   trailing
code/style2.txt:39:34: // comments for single line, or trailing
code/style2.txt:67:2:  trailing punctuation
translate.txt:147:7:   have trailing whitespace -- nuisance for the translator
travis.txt:10:8:       tabs, trailing whitespace

ARRAYs?
attach/attach.h:          FILE **fp_idx;
attach/attach.h:          struct AttachPtr **idx;
attach/attach.h:          struct Body **body_idx;
browser/private_data.h:   char ***files;
complete/data.h:          const char **match_list;
config/mbtable.h:         char **chars;
core/mailbox.h:           struct Email **emails;
core/neomutt.h:           char **env;
email/email.h:            struct Email **emails;
gui/curs_lib.h:           char ***files;
mutt/charset.h:           const char **inrepls;
mutt/hash.h:              struct HashElem **table;
nntp/adata.h:             struct NntpMboxData **groups_list;

certificates
	add relatives to timestamps (X ago, for Y)
	This certificate is valid
	   from Thu, 26 Dec 2024 09:01:01 UTC (x weeks ago)
	     to Wed, 26 Mar 2025 09:01:00 UTC (for y months)
	means lots more translations!
	also key selection

Find more Linked List Nodes, to replace with ARRAY, e.g.
Nodes
	address/group.h:53:2:    STAILQ_HEAD(GroupList,       GroupNode);
	mutt/list.h:41:2:        STAILQ_HEAD(ListHead,        ListNode);
	mutt/observer.h:74:2:    STAILQ_HEAD(ObserverList,    ObserverNode);
	mutt/regex3.h:100:2:     STAILQ_HEAD(RegexList,       RegexNode);
Others
	address/address.h:43:1:   TAILQ_HEAD(AddressList,     Address);
	alias/alias.h:42:1:       TAILQ_HEAD(AliasList,       Alias);
	attach/cid.h:41:2:       STAILQ_HEAD(CidMapList,      CidMap);
	color/attr.h:74:1:        TAILQ_HEAD(AttrColorList,   AttrColor);
	color/curses2.h:48:1:     TAILQ_HEAD(CursesColorList, CursesColor);
	color/regex4.h:47:2:     STAILQ_HEAD(RegexColorList,  RegexColor);
	email/parameter.h:38:1:   TAILQ_HEAD(ParameterList,   Parameter);
	email/tags.h:48:2:       STAILQ_HEAD(TagList,         Tag);
	email/url.h:63:2:        STAILQ_HEAD(UrlQueryList,    UrlQuery);
	gui/mutt_window.h:105:1:  TAILQ_HEAD(MuttWindowList,  MuttWindow);
	hook.c:76:1:              TAILQ_HEAD(HookList,        Hook);
	key/lib.h:76:2:          STAILQ_HEAD(KeymapList,      Keymap);
	mutt/charset.c:80:1:      TAILQ_HEAD(LookupList,      Lookup);
	mutt/logging2.h:88:2:    STAILQ_HEAD(LogLineList,     LogLine);
	mutt/regex3.h:112:2:     STAILQ_HEAD(ReplaceList,     Replace);
	ncrypt/crypt_mod.c:45:2: STAILQ_HEAD(CryptModuleList, CryptModule);

.github README
	welcome

rename *_buffer_*() functions to buf, or strip buffer entirely
char[] -> Buffer conversions
	which?

upstream patches

split up send() to accommodate bg_edit

compose: move Body wrapping into compose

compose: small fns #3222
	<move-to-top>
		simple within a group
		what does it do at the top level?
		altering the first attachment might have consequences
	<move-to-bottom>
		acting on the first attachment might have consequences
	<move-out-of-group>
		moves attached file *after* the group it was in
	<move-into-group>
		moves attached file into the group *above* it

kill the num_accounts and return the value
int mutt_autocrypt_db_account_get_all(struct AutocryptAccount ***accounts, int *num_accounts)

add X_new()/X_free() wrappers for non-trivial objects
	QClass, ListNode
	SmimeKey, PgpUid, MuttThread

free: see neo/[triv/free]

objects must have X_new()/X_free() pair, or neither
	check existing
	51 X_new()
	55 X_free()
	148 struct
	292 [cm]alloc
	find/distinguish between
		struct - simple, data
		object - complex, actions
	data still needs free for ptrs
	too simplistic?

github action
	check for @file header, etc
	*.c need config.h
	*.h need include guard
	check for empty line at eof
	*.c @page
	"calc" undoc'd functions
	shellcheck

eliminate fallthroughs - use functions

why are these 3 charset config not using DT_SLIST?
	they're only allowed *ONE* charset
	mutt_config.c:431:6:  { "charset",            DT_STRING|D_NOT_EMPTY|D_CHARSET_SINGLE, 0,          0, charset_validator,
	mutt_config.c:443:13: { "config_charset",     DT_STRING,                              0,          0, charset_validator,
	nntp/config.c:67:17:  { "newsgroups_charset", DT_STRING,                              IP "utf-8", 0, charset_validator,

bash completion for neomutt, based on: /usr/share/bash-completion/completions/mutt
	∀ cli options
	for aliases too?

update bash complete for configure
	push to management
	dev ml

fuzzy matcher

change Score list to use STAILQ

relative time option for the index_format
	3h (ago), 2d, etc

where is punycode encoded/decoded?
	extract to lib and test

need neomutt glossary (search first)
	add to guide

add more auto-completion

security warnings
	27 For loop variable changed in body
	26 Poorly documented large function
	21 Local variable address stored in non-local memory
	 9 Year field changed using an arithmetic operation without checking for leap year
	 8 Long switch case
	 5 Uncontrolled data used in path expression
	 3 Nested loops with same variable
	 3 Futile conditional
	 2 Time-of-check time-of-use filesystem race condition
	 2 File created without restricting permissions
	 2 Cleartext transmission of sensitive information
	 1 Uncontrolled process operation

turn MoreArgs, MoreArgsF into ONE function and write tests for it
	SKIPWS too?
	generate tests first
	then convert to functions
	then merge functions
find users of all the flags
doc common uses of each flag, e.g. a regex, a file, a colour, a comment, a keybinding, a pattern
suggest better methods for parsing these

merge string/Buffer variants of functions
	(find them all first)

source! (no error if not exist)
	or `source -q`?
		sort of implies that it'll quieten all errors from the source'd file
source -d dir (all of dir/*.rc or *.conf)?
	alphabetical / collate
	or `source dir.d` (.d significant) -> find all children or just '*.rc'
muttrc ifdef
	/file absolute
	./file relative source
"source" command relative to $cwd or previous file
source DIR
	=> all children
source command -- allow wildcards
	fits in nicely with ifndef
	or 'source_dir' command to read all contents
	or "source dir" to read all contents
	recursive option?
	recursive by default?

update buf_at() to take negative offsets
	-1 == end of string
	find uses, look for buf_len() or buf->dsize

create buf_tell() cf buf_seek()
	to show dptr position relative to data

upgrade buf_seek() to match fseek()
	using SEEK_SET, SEEK_CUR, or SEEK_END (<stdio.h>)
	or our own BUF_ enums

rename *_buffer_*() functions to buf, or strip buffer entirely
rename *_buffer_*() functions to buf, or strip buffer entirely
3	mutt_b64_buffer_decode
5		mutt_b64_decode
4	mutt_b64_buffer_encode
8		mutt_b64_encode
2	mutt_socket_buffer_readln
19		mutt_socket_readln
1	mutt_socket_buffer_readln_d
12		mutt_socket_readln_d
test_mutt_b64_buffer_decode
test_mutt_b64_buffer_encode
find all functions with a Buffer parameter
	some functions might **append** to the dest buffer

refactor "not reached"
	8	ag "not reached"

find potential places for struct Buffer
	691	ag "([a-z_]+(->[a-z_]+)*), sizeof\(\1\)"
	37	ag "([a-z_]+(->[a-z_]+)*)-\>data, \1-\>dsize"

EBNF for all 88 commands?

doxy: next big area for coverage?
	defines 40%

:changelog ?
	read from /usr/share/doc/neomutt

prep dyk
	need doc repo for saving emails

devel guide: "how to bisect"
	target audience: developer with basic git understanding
	and ability to build neomutt

add "Add profile picture" to welcome letter
add build and analysis pages to welcome email
	revamp newbie page
collate all my welcome emails
	generate single webpage

repo/org .github README
	web/readme bigger deal about starring/donation
	IPA NeoMutt /ˌniːoʊ/ /mʌt/

Misc
	where are the "source" relative docs?
	alias_file, certificate_file, etc aren't relative
		alias_file
		certificate_file
		debug_file
		history_file
		ssl_ca_certificates_file
	relative to what?
	all *_files relative to:
	1) the source file they're read from
	2) current working directory
	3) User's muttrc? NO
	4) $XDG_CACHE_HOME? NO

how to build neomutt
	w.r.t. neomutt -v
	dependencies

summarise the last year's commits
	then weekly

take my original config docs, plus the diagrams and improve them

∀ command, list:
	where its data is ultimately stored
	who owns the data
	1	Alias Commands (2): alias, unalias
	2	Hook Commands (18): Various hooks like account-hook, folder-hook, send-hook, etc.
	3	Key Binding Commands (6): bind, unbind, macro, unmacro, exec, push
	4	Configuration Commands (10): set, unset, reset, toggle, setenv, unsetenv, etc.
	5	List Management Commands (12): Various list commands and their "un" counterparts
	6	Hook/Pattern Commands (15): Score, spam, color, ignore commands
	7	Mailbox Commands (3): mailboxes, named-mailboxes, unmailboxes
	8	Utility Commands (7): source, echo, cd, version, etc.
	9	Conditional Commands (4): ifdef, ifndef, finish
	10	Other Commands (12): Remaining specialized commands

using `unbind` as a template
	split up all commands
	COMMAND-NAME ->
		parse_command_name()		main handler
		parse_command_name_args()	split line into tokens
			-> struct ParseCommandNameArgs
		parse_command_name_execute()	do the work
	write tests for all _args() functions
		100% coverage
	add _args() to fuzzer?
	might affect parsing
	`mailboxes good1 bad good2; other command`
	current parser fails at 'bad' and stops parsing
	new parser would try to parse until EOL or `;`
		this would allow the option of executing subsequent commands
		probably best to stop on failed command
	arg parser should record where in the statement the arg came from
	error at line X, column Y

