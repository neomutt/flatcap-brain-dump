diff --git a/address/address.c b/address/address.c
@@ @@
 */
struct Address *mutt_addr_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Address));
}

/**
diff --git a/address/config_type.c b/address/config_type.c
@@ @@
 */
struct Address *address_new(const char *addr)
{
  struct Address *a = mutt_mem_calloc(1, sizeof(*a));
  a->mailbox = buf_new(addr);
  return a;
}
@@ @@
  if (!addr)
    return NULL; /* LCOV_EXCL_LINE */

  struct Address *a = mutt_mem_calloc(1, sizeof(*a));
  a->personal = buf_dup(addr->personal);
  a->mailbox = buf_dup(addr->mailbox);
  return a;
diff --git a/address/group.c b/address/group.c
@@ @@
 */
static struct Group *group_new(const char *pat)
{
  struct Group *g = mutt_mem_calloc(1, sizeof(struct Group));

  g->name = mutt_str_dup(pat);
  STAILQ_INIT(&g->rs);
@@ @@
    if (np->group == group)
      return;
  }
  np = mutt_mem_calloc(1, sizeof(struct GroupNode));
  np->group = group;
  STAILQ_INSERT_TAIL(gl, np, entries);
}
diff --git a/alias/alias.c b/alias/alias.c
@@ @@
 */
struct Alias *alias_new(void)
{
  struct Alias *a = mutt_mem_calloc(1, sizeof(struct Alias));
  TAILQ_INIT(&a->addr);
  STAILQ_INIT(&a->tags);
  return a;
diff --git a/attach/attach.c b/attach/attach.c
@@ @@
 */
struct AttachPtr *mutt_aptr_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct AttachPtr));
}

/**
@@ @@
 */
struct AttachCtx *mutt_actx_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct AttachCtx));
}

/**
diff --git a/attach/attachments.c b/attach/attachments.c
@@ @@
 */
static struct AttachMatch *attachmatch_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct AttachMatch));
}

/**
diff --git a/attach/cid.c b/attach/cid.c
@@ @@
  if (!cid || !filename)
    return NULL;

  struct CidMap *cid_map = mutt_mem_calloc(1, sizeof(struct CidMap));

  cid_map->cid = mutt_str_dup(cid);
  cid_map->fname = mutt_str_dup(filename);
diff --git a/attach/private_data.c b/attach/private_data.c
@@ @@
 */
struct AttachPrivateData *attach_private_data_new(void)
{
  struct AttachPrivateData *priv = mutt_mem_calloc(1, sizeof(struct AttachPrivateData));

  return priv;
}
diff --git a/autocrypt/db.c b/autocrypt/db.c
@@ @@
 */
struct AutocryptAccount *mutt_autocrypt_db_account_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct AutocryptAccount));
}

/**
@@ @@
 */
struct AutocryptPeer *mutt_autocrypt_db_peer_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct AutocryptPeer));
}

/**
@@ @@
 */
struct AutocryptPeerHistory *mutt_autocrypt_db_peer_history_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct AutocryptPeerHistory));
}

/**
@@ @@
 */
struct AutocryptGossipHistory *mutt_autocrypt_db_gossip_history_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct AutocryptGossipHistory));
}

/**
diff --git a/autocrypt/dlg_autocrypt.c b/autocrypt/dlg_autocrypt.c
@@ @@
  if (mutt_autocrypt_db_account_get_all(&accounts, &num_accounts) < 0)
    return false;

  struct AccountEntry *entries = mutt_mem_calloc(num_accounts, sizeof(struct AccountEntry));
  menu->mdata = entries;
  menu->mdata_free = autocrypt_menu_free;
  menu->max = num_accounts;
diff --git a/bcache/bcache.c b/bcache/bcache.c
@@ @@
  if (!account)
    return NULL;

  struct BodyCache *bcache = mutt_mem_calloc(1, sizeof(struct BodyCache));
  if (bcache_path(account, mailbox, bcache) < 0)
  {
    mutt_bcache_close(&bcache);
diff --git a/browser/functions.c b/browser/functions.c
@@ @@
    if (priv->menu->num_tagged)
    {
      *priv->numfiles = priv->menu->num_tagged;
      tfiles = mutt_mem_calloc(*priv->numfiles, sizeof(char *));
      size_t j = 0;
      struct FolderFile *ff = NULL;
      ARRAY_FOREACH(ff, &priv->state.entry)
@@ @@
    else if (!buf_is_empty(priv->file)) /* no tagged entries. return selected entry */
    {
      *priv->numfiles = 1;
      tfiles = mutt_mem_calloc(*priv->numfiles, sizeof(char *));
      buf_expand_path(priv->file);
      tfiles[0] = buf_strdup(priv->file);
      *priv->files = tfiles;
diff --git a/browser/private_data.c b/browser/private_data.c
@@ @@
 */
struct BrowserPrivateData *browser_private_data_new(void)
{
  struct BrowserPrivateData *priv = mutt_mem_calloc(1, sizeof(struct BrowserPrivateData));

  priv->old_last_dir = buf_pool_get();
  priv->prefix = buf_pool_get();
diff --git a/color/attr.c b/color/attr.c
@@ @@
 */
struct AttrColor *attr_color_new(void)
{
  struct AttrColor *ac = mutt_mem_calloc(1, sizeof(*ac));

  ac->fg.color = COLOR_DEFAULT;
  ac->fg.type = CT_SIMPLE;
diff --git a/color/curses.c b/color/curses.c
@@ @@
  if (index == 0)
    return NULL;

  struct CursesColor *cc_new = mutt_mem_calloc(1, sizeof(*cc_new));
  NumCursesColors++;
  color_debug(LL_DEBUG5, "CursesColor %p\n", (void *) cc_new);
  cc_new->fg = fg;
diff --git a/color/quoted.c b/color/quoted.c
@@ @@
 */
static struct QuoteStyle *qstyle_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct QuoteStyle));
}

/**
diff --git a/color/regex.c b/color/regex.c
@@ @@
 */
struct RegexColor *regex_color_new(void)
{
  struct RegexColor *rcol = mutt_mem_calloc(1, sizeof(*rcol));

  return rcol;
}

/**
diff --git a/complete/data.c b/complete/data.c
@@ @@
 */
struct CompletionData *completion_data_new(void)
{
  struct CompletionData *cd = mutt_mem_calloc(1, sizeof(struct CompletionData));

  cd->match_list_len = 512;
  cd->match_list = mutt_mem_calloc(cd->match_list_len, sizeof(char *));

  return cd;
}
diff --git a/compmbox/compress.c b/compmbox/compress.c
@@ @@
  const char *c = mutt_find_hook(MUTT_CLOSE_HOOK, mailbox_path(m));
  const char *a = mutt_find_hook(MUTT_APPEND_HOOK, mailbox_path(m));

  struct CompressInfo *ci = mutt_mem_calloc(1, sizeof(struct CompressInfo));
  m->compress_info = ci;

  ci->cmd_open = validate_compress_expando(o);
diff --git a/compose/attach_data.c b/compose/attach_data.c
@@ @@
 */
struct ComposeAttachData *attach_data_new(struct Email *e)
{
  struct ComposeAttachData *attach_data = mutt_mem_calloc(1, sizeof(struct ComposeAttachData));

  attach_data->actx = mutt_actx_new();
  attach_data->actx->email = e;
diff --git a/compose/cbar_data.c b/compose/cbar_data.c
@@ @@
 */
struct ComposeBarData *cbar_data_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct ComposeBarData));
}
diff --git a/compose/shared_data.c b/compose/shared_data.c
@@ @@
 */
struct ComposeSharedData *compose_shared_data_new(void)
{
  struct ComposeSharedData *shared = mutt_mem_calloc(1, sizeof(struct ComposeSharedData));

  return shared;
}
diff --git a/compress/lz4.c b/compress/lz4.c
@@ @@
 */
static struct Lz4ComprData *lz4_cdata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Lz4ComprData));
}

/**
@@ @@
{
  struct Lz4ComprData *cdata = lz4_cdata_new();

  cdata->buf = mutt_mem_calloc(1, LZ4_compressBound(1024 * 32));

  if ((level < MIN_COMP_LEVEL) || (level > MAX_COMP_LEVEL))
  {
diff --git a/compress/zlib.c b/compress/zlib.c
@@ @@
 */
static struct ZlibComprData *zlib_cdata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct ZlibComprData));
}

/**
@@ @@
{
  struct ZlibComprData *cdata = zlib_cdata_new();

  cdata->buf = mutt_mem_calloc(1, compressBound(1024 * 32));

  if ((level < MIN_COMP_LEVEL) || (level > MAX_COMP_LEVEL))
  {
diff --git a/compress/zstd.c b/compress/zstd.c
@@ @@
 */
static struct ZstdComprData *zstd_cdata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct ZstdComprData));
}

/**
@@ @@
{
  struct ZstdComprData *cdata = zstd_cdata_new();

  cdata->buf = mutt_mem_calloc(1, ZSTD_compressBound(1024 * 128));
  cdata->cctx = ZSTD_createCCtx();
  cdata->dctx = ZSTD_createDCtx();

diff --git a/config/mbtable.c b/config/mbtable.c
@@ @@
  if (!slen)
    return NULL;

  t = mutt_mem_calloc(1, sizeof(struct MbTable));

  t->orig_str = mutt_str_dup(s);
  /* This could be more space efficient.  However, being used on tiny
   * strings (`$to_chars` and `$status_chars`), the overhead is not great. */
  t->chars = mutt_mem_calloc(slen, sizeof(char *));
  t->segmented_str = mutt_mem_calloc(slen * 2, sizeof(char));
  d = t->segmented_str;

  while (slen && (k = mbrtowc(NULL, s, slen, &mbstate)))
@@ @@
  if (!table)
    return NULL; /* LCOV_EXCL_LINE */

  struct MbTable *m = mutt_mem_calloc(1, sizeof(*m));
  m->orig_str = mutt_str_dup(table->orig_str);
  return m;
}
diff --git a/config/regex.c b/config/regex.c
@@ @@
    return NULL;

  int rflags = 0;
  struct Regex *reg = mutt_mem_calloc(1, sizeof(struct Regex));

  reg->regex = mutt_mem_calloc(1, sizeof(regex_t));
  reg->pattern = mutt_str_dup(str);

  /* Should we use smart case matching? */
diff --git a/config/set.c b/config/set.c
@@ @@
 */
struct ConfigSet *cs_new(size_t size)
{
  struct ConfigSet *cs = mutt_mem_calloc(1, sizeof(*cs));

  cs->hash = mutt_hash_new(size, MUTT_HASH_NO_FLAGS);
  mutt_hash_set_destructor(cs->hash, cs_hashelem_free, (intptr_t) cs);
@@ @@
struct HashElem *cs_create_variable(const struct ConfigSet *cs, struct ConfigDef *cdef, struct Buffer *err)
{
  struct ConfigDef *cdef_copy = mutt_mem_calloc(1, sizeof(struct ConfigDef));
  cdef_copy->name = mutt_str_dup(cdef->name);
  cdef_copy->type = cdef->type | D_INTERNAL_FREE_CONFIGDEF;
  cdef_copy->initial = cdef->initial;
@@ @@
  if (DTYPE(he_parent->type) == DT_MYVAR)
    return NULL;

  struct Inheritance *i = mutt_mem_calloc(1, sizeof(*i));
  i->parent = he_parent;
  i->name = mutt_str_dup(name);

diff --git a/config/subset.c b/config/subset.c
@@ @@
  if (!cs)
    return NULL;

  struct HashElem **he_list = mutt_mem_calloc(1024, sizeof(struct HashElem *));
  size_t index = 0;

  struct HashWalkState walk = { 0 };
@@ @@
struct ConfigSubset *cs_subset_new(const char *name, struct ConfigSubset *sub_parent, struct Notify *not_parent)
{
  struct ConfigSubset *sub = mutt_mem_calloc(1, sizeof(*sub));

  if (sub_parent)
  {
diff --git a/conn/gnutls.c b/conn/gnutls.c
@@ @@
    return 0;

  b64_data.size = st.st_size;
  b64_data_data = mutt_mem_calloc(1, b64_data.size + 1);
  b64_data.data = b64_data_data;

  FILE *fp = mutt_file_fopen(c_certificate_file, "r");
@@ @@
                                     0, NULL, &cnlen);
  if (((rc >= 0) || (rc == GNUTLS_E_SHORT_MEMORY_BUFFER)) && (cnlen > 0))
  {
    cn = mutt_mem_calloc(1, cnlen);
    if (gnutls_x509_crt_get_dn_by_oid(clientcrt, GNUTLS_OID_X520_COMMON_NAME, 0, 0, cn, &cnlen) < 0)
    {
@@ @@
 */
static int tls_negotiate(struct Connection *conn)
{
  struct TlsSockData *data = mutt_mem_calloc(1, sizeof(struct TlsSockData));
  conn->sockdata = data;
  int err = gnutls_certificate_allocate_credentials(&data->xcred);
  if (err < 0)
diff --git a/conn/openssl.c b/conn/openssl.c
@@ @@
{
  int maxbits = 0;

  conn->sockdata = mutt_mem_calloc(1, sizeof(struct SslSockData));

  sockdata(conn)->sctx = SSL_CTX_new(SSLv23_client_method());
  if (!sockdata(conn)->sctx)
diff --git a/conn/socket.c b/conn/socket.c
@@ @@
 */
struct Connection *mutt_socket_new(enum ConnectionType type)
{
  struct Connection *conn = mutt_mem_calloc(1, sizeof(struct Connection));
  conn->fd = -1;

  if (type == MUTT_CONNECTION_TUNNEL)
diff --git a/conn/zstrm.c b/conn/zstrm.c
@@ @@
 */
void mutt_zstrm_wrap_conn(struct Connection *conn)
{
  struct ZstrmContext *zctx = mutt_mem_calloc(1, sizeof(struct ZstrmContext));

  /* store wrapped stream as next stream */
  zctx->next_conn.fd = conn->fd;
diff --git a/convert/content_info.c b/convert/content_info.c
@@ @@
    return NULL;
  }

  info = mutt_mem_calloc(1, sizeof(struct Content));

  const char *const c_charset = cc_charset();
  if (b && (b->type == TYPE_TEXT) && (!b->noconv && !b->force_charset))
diff --git a/convert/convert.c b/convert/convert.c
@@ @@
    return -1;

  int ncodes = tocodes->count;
  iconv_t *cd = mutt_mem_calloc(ncodes, sizeof(iconv_t));
  size_t *score = mutt_mem_calloc(ncodes, sizeof(size_t));
  struct ContentState *states = mutt_mem_calloc(ncodes, sizeof(struct ContentState));
  struct Content *infos = mutt_mem_calloc(ncodes, sizeof(struct Content));

  struct ListNode *np = NULL;
  int ni = 0;
@@ @@
  struct ListNode *np = NULL;

  /* Copy them */
  tcode = mutt_mem_calloc(tocodes->count, sizeof(char *));
  np = NULL;
  cn = 0;
  STAILQ_FOREACH(np, &tocodes->head, entries)
diff --git a/core/account.c b/core/account.c
@@ @@
  if (!sub)
    return NULL;

  struct Account *a = mutt_mem_calloc(1, sizeof(struct Account));

  STAILQ_INIT(&a->mailboxes);
  a->notify = notify_new();
@@ @@
    a->type = m->type;

  m->account = a;
  struct MailboxNode *np = mutt_mem_calloc(1, sizeof(*np));
  np->mailbox = m;
  STAILQ_INSERT_TAIL(&a->mailboxes, np, entries);
  mailbox_set_subset(m, a->sub);
diff --git a/core/mailbox.c b/core/mailbox.c
@@ @@
 */
struct Mailbox *mailbox_new(void)
{
  struct Mailbox *m = mutt_mem_calloc(1, sizeof(struct Mailbox));

  buf_init(&m->pathbuf);
  m->notify = notify_new();

  m->email_max = 25;
  m->emails = mutt_mem_calloc(m->email_max, sizeof(struct Email *));
  m->v2r = mutt_mem_calloc(m->email_max, sizeof(int));
  m->gen = mailbox_gen();
  m->notify_user = true;
  m->poll_new_mail = true;
diff --git a/core/message.c b/core/message.c
@@ @@
 */
struct Message *message_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Message));
}
diff --git a/core/neomutt.c b/core/neomutt.c
@@ @@
  if (!cs)
    return NULL;

  struct NeoMutt *n = mutt_mem_calloc(1, sizeof(*NeoMutt));

  TAILQ_INIT(&n->accounts);
  n->notify = notify_new();
@@ @@

    STAILQ_FOREACH(mn, &a->mailboxes, entries)
    {
      struct MailboxNode *mn2 = mutt_mem_calloc(1, sizeof(*mn2));
      mn2->mailbox = mn->mailbox;
      STAILQ_INSERT_TAIL(head, mn2, entries);
      count++;
diff --git a/editor/functions.c b/editor/functions.c
@@ @@

  if (savelen)
  {
    savebuf = mutt_mem_calloc(savelen, sizeof(wchar_t));
    wmemcpy(savebuf, es->wbuf + es->curpos, savelen);
  }

diff --git a/editor/state.c b/editor/state.c
@@ @@
 */
struct EnterState *enter_state_new(void)
{
  struct EnterState *es = mutt_mem_calloc(1, sizeof(struct EnterState));

  enter_state_resize(es, 1);

diff --git a/editor/window.c b/editor/window.c
@@ @@
      {
        char **tfiles = NULL;
        *cdata->numfiles = 1;
        tfiles = mutt_mem_calloc(*cdata->numfiles, sizeof(char *));
        buf_expand_path_regex(wdata->buffer, false);
        tfiles[0] = buf_strdup(wdata->buffer);
        *cdata->files = tfiles;
diff --git a/email/body.c b/email/body.c
@@ @@
 */
struct Body *mutt_body_new(void)
{
  struct Body *p = mutt_mem_calloc(1, sizeof(struct Body));

  p->disposition = DISP_ATTACH;
  p->use_disp = true;
diff --git a/email/email.c b/email/email.c
@@ @@
{
  static size_t sequence = 0;

  struct Email *e = mutt_mem_calloc(1, sizeof(struct Email));
#ifdef MIXMASTER
  STAILQ_INIT(&e->chain);
#endif
diff --git a/email/envelope.c b/email/envelope.c
@@ @@
 */
struct Envelope *mutt_env_new(void)
{
  struct Envelope *env = mutt_mem_calloc(1, sizeof(struct Envelope));
  TAILQ_INIT(&env->return_path);
  TAILQ_INIT(&env->from);
  TAILQ_INIT(&env->to);
@@ @@
 */
struct AutocryptHeader *mutt_autocrypthdr_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct AutocryptHeader));
}

/**
diff --git a/email/parameter.c b/email/parameter.c
@@ @@
 */
struct Parameter *mutt_param_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Parameter));
}

/**
diff --git a/email/rfc2231.c b/email/rfc2231.c
@@ @@
 */
static struct Rfc2231Parameter *parameter_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Rfc2231Parameter));
}

/**
diff --git a/email/tags.c b/email/tags.c
@@ @@
 */
struct Tag *tag_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Tag));
}

/**
diff --git a/email/url.c b/email/url.c
@@ @@
    if ((url_pct_decode(key) < 0) || (url_pct_decode(val) < 0))
      return false;

    struct UrlQuery *qs = mutt_mem_calloc(1, sizeof(struct UrlQuery));
    qs->name = key;
    qs->value = val;
    STAILQ_INSERT_TAIL(list, qs, entries);
@@ @@
 */
static struct Url *url_new(void)
{
  struct Url *url = mutt_mem_calloc(1, sizeof(struct Url));
  STAILQ_INIT(&url->query_strings);
  return url;
}
diff --git a/enriched.c b/enriched.c
@@ @@
                             state->wraplen - 4 :
                             72;
  enriched.line_max = enriched.wrap_margin * 4;
  enriched.line = mutt_mem_calloc((enriched.line_max + 1), sizeof(wchar_t));
  enriched.param = mutt_mem_calloc(256, sizeof(wchar_t));

  enriched.param_len = 256;
  enriched.param_used = 0;
diff --git a/envelope/wdata.c b/envelope/wdata.c
@@ @@
 */
struct EnvelopeWindowData *env_wdata_new(void)
{
  struct EnvelopeWindowData *wdata = mutt_mem_calloc(1, sizeof(struct EnvelopeWindowData));

#ifdef USE_AUTOCRYPT
  wdata->autocrypt_rec = AUTOCRYPT_REC_OFF;
diff --git a/expando/expando.c b/expando/expando.c
@@ @@
 */
struct Expando *expando_new(const char *format)
{
  struct Expando *exp = mutt_mem_calloc(1, sizeof(struct Expando));
  exp->string = mutt_str_dup(format);
  return exp;
}
diff --git a/expando/node.c b/expando/node.c
@@ @@
 */
struct ExpandoNode *node_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct ExpandoNode));
}

/**
diff --git a/expando/node_conddate.c b/expando/node_conddate.c
@@ @@
 */
struct NodeCondDatePrivate *node_conddate_private_new(int count, char period)
{
  struct NodeCondDatePrivate *priv = mutt_mem_calloc(1, sizeof(struct NodeCondDatePrivate));

  priv->count = count;
  priv->period = period;
diff --git a/expando/node_expando.c b/expando/node_expando.c
@@ @@
 */
struct NodeExpandoPrivate *node_expando_private_new(void)
{
  struct NodeExpandoPrivate *priv = mutt_mem_calloc(1, sizeof(struct NodeExpandoPrivate));

  // NOTE(g0mb4): Expando definition should contain this
  priv->color = -1;
@@ @@
  if (start == end)
    return NULL;

  struct ExpandoFormat *fmt = mutt_mem_calloc(1, sizeof(struct ExpandoFormat));

  fmt->leader = ' ';
  fmt->start = start;
diff --git a/expando/node_padding.c b/expando/node_padding.c
@@ @@
 */
struct NodePaddingPrivate *node_padding_private_new(enum ExpandoPadType pad_type)
{
  struct NodePaddingPrivate *priv = mutt_mem_calloc(1, sizeof(struct NodePaddingPrivate));

  priv->pad_type = pad_type;

diff --git a/gui/msgwin_wdata.c b/gui/msgwin_wdata.c
@@ @@
 */
struct MsgWinWindowData *msgwin_wdata_new(void)
{
  struct MsgWinWindowData *wdata = mutt_mem_calloc(1, sizeof(struct MsgWinWindowData));

  wdata->text = buf_new(NULL);

diff --git a/gui/mutt_window.c b/gui/mutt_window.c
@@ @@
struct MuttWindow *mutt_window_new(enum WindowType type, enum MuttWindowOrientation orient, enum MuttWindowSize size, int cols, int rows)
{
  struct MuttWindow *win = mutt_mem_calloc(1, sizeof(struct MuttWindow));

  win->type = type;
  win->orient = orient;
diff --git a/gui/sbar.c b/gui/sbar.c
@@ @@
 */
static struct SBarPrivateData *sbar_data_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct SBarPrivateData));
}

/**
diff --git a/hcache/hcache.c b/hcache/hcache.c
@@ @@
 */
static struct HeaderCache *hcache_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct HeaderCache));
}

/**
diff --git a/helpbar/wdata.c b/helpbar/wdata.c
@@ @@
 */
struct HelpbarWindowData *helpbar_wdata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct HelpbarWindowData));
}

/**
diff --git a/history/history.c b/history/history.c
@@ @@

  const short c_history = cs_subset_number(NeoMutt->sub, "history");
  if (c_history != 0)
    h->hist = mutt_mem_calloc(c_history + 1, sizeof(char *));

  h->cur = 0;
  h->last = 0;
@@ @@
void mutt_hist_complete(char *buf, size_t buflen, enum HistoryClass hclass)
{
  const short c_history = cs_subset_number(NeoMutt->sub, "history");
  char **matches = mutt_mem_calloc(c_history, sizeof(char *));
  int match_count = mutt_hist_search(buf, hclass, matches);
  if (match_count)
  {
diff --git a/hook.c b/hook.c
@@ @@
 */
static struct Hook *hook_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Hook));
}

/**
@@ @@
  else if (~data & MUTT_GLOBAL_HOOK) /* NOT a global hook */
  {
    /* Hooks not allowing full patterns: Check syntax of regex */
    rx = mutt_mem_calloc(1, sizeof(regex_t));
    int rc2 = REG_COMP(rx, buf_string(pattern), ((data & MUTT_CRYPT_HOOK) ? REG_ICASE : 0));
    if (rc2 != 0)
    {
@@ @@

  if (!hl)
  {
    hl = mutt_mem_calloc(1, sizeof(*hl));
    TAILQ_INIT(hl);
    mutt_hash_insert(IdxFmtHooks, buf_string(name), hl);
  }
diff --git a/imap/adata.c b/imap/adata.c
@@ @@
 */
struct ImapAccountData *imap_adata_new(struct Account *a)
{
  struct ImapAccountData *adata = mutt_mem_calloc(1, sizeof(struct ImapAccountData));
  adata->account = a;

  static unsigned char new_seqid = 'a';
@@ @@
  adata->seqid = new_seqid;
  const short c_imap_pipeline_depth = cs_subset_number(NeoMutt->sub, "imap_pipeline_depth");
  adata->cmdslots = c_imap_pipeline_depth + 2;
  adata->cmds = mutt_mem_calloc(adata->cmdslots, sizeof(*adata->cmds));

  if (++new_seqid > 'z')
    new_seqid = 'a';
diff --git a/imap/edata.c b/imap/edata.c
@@ @@
 */
struct ImapEmailData *imap_edata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct ImapEmailData));
}

/**
diff --git a/imap/mdata.c b/imap/mdata.c
@@ @@
struct ImapMboxData *imap_mdata_new(struct ImapAccountData *adata, const char *name)
{
  char buf[1024] = { 0 };
  struct ImapMboxData *mdata = mutt_mem_calloc(1, sizeof(struct ImapMboxData));

  mdata->real_name = mutt_str_dup(name);

diff --git a/imap/util.c b/imap/util.c
@@ @@
  if (!seqset || (*seqset == '\0'))
    return NULL;

  struct SeqsetIterator *iter = mutt_mem_calloc(1, sizeof(struct SeqsetIterator));
  iter->full_seqset = mutt_str_dup(seqset);
  iter->eostr = strchr(iter->full_seqset, '\0');
  iter->substr_cur = iter->substr_end = iter->full_seqset;
diff --git a/index/ibar.c b/index/ibar.c
@@ @@
static struct IBarPrivateData *ibar_data_new(struct IndexSharedData *shared, struct IndexPrivateData *priv)
{
  struct IBarPrivateData *ibar_data = mutt_mem_calloc(1, sizeof(struct IBarPrivateData));

  ibar_data->shared = shared;
  ibar_data->priv = priv;
diff --git a/index/private_data.c b/index/private_data.c
@@ @@
 */
struct IndexPrivateData *index_private_data_new(struct IndexSharedData *shared)
{
  struct IndexPrivateData *priv = mutt_mem_calloc(1, sizeof(struct IndexPrivateData));

  priv->shared = shared;
  priv->oldcount = -1;
diff --git a/index/shared_data.c b/index/shared_data.c
@@ @@
 */
struct IndexSharedData *index_shared_data_new(void)
{
  struct IndexSharedData *shared = mutt_mem_calloc(1, sizeof(struct IndexSharedData));

  shared->notify = notify_new();
  shared->sub = NeoMutt->sub;
diff --git a/key/lib.c b/key/lib.c
@@ @@
 */
struct Keymap *alloc_keys(size_t len, keycode_t *keys)
{
  struct Keymap *p = mutt_mem_calloc(1, sizeof(struct Keymap));
  p->len = len;
  p->keys = mutt_mem_calloc(len, sizeof(keycode_t));
  memcpy(p->keys, keys, len * sizeof(keycode_t));
  return p;
}
diff --git a/mailcap.c b/mailcap.c
@@ @@
 */
struct MailcapEntry *mailcap_entry_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct MailcapEntry));
}

/**
diff --git a/maildir/edata.c b/maildir/edata.c
@@ @@
 */
struct MaildirEmailData *maildir_edata_new(void)
{
  struct MaildirEmailData *edata = mutt_mem_calloc(1, sizeof(struct MaildirEmailData));
  return edata;
}

/**
diff --git a/maildir/mdata.c b/maildir/mdata.c
@@ @@
 */
struct MaildirMboxData *maildir_mdata_new(void)
{
  struct MaildirMboxData *mdata = mutt_mem_calloc(1, sizeof(struct MaildirMboxData));
  return mdata;
}

/**
diff --git a/maildir/mdemail.c b/maildir/mdemail.c
@@ @@
 */
struct MdEmail *maildir_entry_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct MdEmail));
}

/**
diff --git a/mbox/mbox.c b/mbox/mbox.c
@@ @@
 */
static struct MboxAccountData *mbox_adata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct MboxAccountData));
}

/**
@@ @@
    offset -= (sizeof(MMDF_SEP) - 1);

  /* allocate space for the new offsets */
  new_offset = mutt_mem_calloc(m->msg_count - first, sizeof(struct MUpdate));
  old_offset = mutt_mem_calloc(m->msg_count - first, sizeof(struct MUpdate));

  if (m->verbose)
  {
diff --git a/menu/menu.c b/menu/menu.c
@@ @@
 */
struct Menu *menu_new(enum MenuType type, struct MuttWindow *win, struct ConfigSubset *sub)
{
  struct Menu *menu = mutt_mem_calloc(1, sizeof(struct Menu));

  menu->type = type;
  menu->redraw = MENU_REDRAW_FULL;
diff --git a/mh/mdata.c b/mh/mdata.c
@@ @@
 */
struct MhMboxData *mh_mdata_new(void)
{
  struct MhMboxData *mdata = mutt_mem_calloc(1, sizeof(struct MhMboxData));
  return mdata;
}

/**
diff --git a/mh/mhemail.c b/mh/mhemail.c
@@ @@
 */
struct MhEmail *mh_entry_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct MhEmail));
}

/**
diff --git a/mixmaster/chain_data.c b/mixmaster/chain_data.c
@@ @@
 */
struct ChainData *chain_data_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct ChainData));
}

/**
diff --git a/mixmaster/remailer.c b/mixmaster/remailer.c
@@ @@
 */
struct Remailer *remailer_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Remailer));
}

/**
diff --git a/monitor.c b/monitor.c
@@ @@
 */
static struct Monitor *monitor_new(struct MonitorInfo *info, int descriptor)
{
  struct Monitor *monitor = mutt_mem_calloc(1, sizeof(struct Monitor));
  monitor->type = info->type;
  monitor->st_dev = info->st_dev;
  monitor->st_ino = info->st_ino;
diff --git a/mutt/buffer.c b/mutt/buffer.c
@@ @@
 */
struct Buffer *buf_new(const char *str)
{
  struct Buffer *buf = mutt_mem_calloc(1, sizeof(struct Buffer));

  if (str)
    buf_addstr(buf, str);
diff --git a/mutt/charset.c b/mutt/charset.c
@@ @@
 */
static struct Lookup *lookup_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Lookup));
}

/**
@@ @@
  if (!pat || !replace)
    return false;

  regex_t *rx = mutt_mem_calloc(1, sizeof(regex_t));
  int rc = REG_COMP(rx, pat, REG_ICASE);
  if (rc != 0)
  {
diff --git a/mutt/envlist.c b/mutt/envlist.c
@@ @@
  for (src = envp; src && *src; src++)
    count++;

  char **env_copy = mutt_mem_calloc(count + 1, sizeof(char *));
  for (src = envp, dst = env_copy; src && *src; src++, dst++)
    *dst = mutt_str_dup(*src);

diff --git a/mutt/hash.c b/mutt/hash.c
@@ @@
 */
static struct HashTable *hash_new(size_t num_elems)
{
  struct HashTable *table = mutt_mem_calloc(1, sizeof(struct HashTable));
  if (num_elems == 0)
    num_elems = 2;
  table->num_elems = num_elems;
  table->table = mutt_mem_calloc(num_elems, sizeof(struct HashElem *));
  return table;
}

@@ @@
  if (!table)
    return NULL; // LCOV_EXCL_LINE

  struct HashElem *he = mutt_mem_calloc(1, sizeof(struct HashElem));
  size_t hash = table->gen_hash(key, table->num_elems);
  he->key = key;
  he->data = data;
diff --git a/mutt/list.c b/mutt/list.c
@@ @@
  if (!h)
    return NULL;

  struct ListNode *np = mutt_mem_calloc(1, sizeof(struct ListNode));
  np->data = s;
  STAILQ_INSERT_HEAD(h, np, entries);
  return np;
@@ @@
  if (!h)
    return NULL;

  struct ListNode *np = mutt_mem_calloc(1, sizeof(struct ListNode));
  np->data = s;
  STAILQ_INSERT_TAIL(h, np, entries);
  return np;
@@ @@
  if (!h || !n)
    return NULL;

  struct ListNode *np = mutt_mem_calloc(1, sizeof(struct ListNode));
  np->data = s;
  STAILQ_INSERT_AFTER(h, n, np, entries);
  return np;
diff --git a/mutt/logging.c b/mutt/logging.c
@@ @@
    level = LL_ERROR;
  }

  struct LogLine *ll = mutt_mem_calloc(1, sizeof(*ll));
  ll->time = (stamp != 0) ? stamp : mutt_date_now();
  ll->file = file;
  ll->line = line;
diff --git a/mutt/mbyte.c b/mutt/mbyte.c
@@ @@
  FREE(s);

  if (buf_is_empty(buf))
    *s = mutt_mem_calloc(1, 1); // Fake empty string
  else
    *s = buf_strdup(buf);

diff --git a/mutt/notify.c b/mutt/notify.c
@@ @@
 */
struct Notify *notify_new(void)
{
  struct Notify *notify = mutt_mem_calloc(1, sizeof(*notify));

  STAILQ_INIT(&notify->observers);

@@ @@
      return true;
  }

  struct Observer *o = mutt_mem_calloc(1, sizeof(*o));
  o->type = type;
  o->callback = callback;
  o->global_data = global_data;

  np = mutt_mem_calloc(1, sizeof(*np));
  np->observer = o;
  STAILQ_INSERT_HEAD(&notify->observers, np, entries);

diff --git a/mutt/prex.c b/mutt/prex.c
@@ @@
    uint32_t ccount = 0;
    pcre2_pattern_info(h->re, PCRE2_INFO_CAPTURECOUNT, &ccount);
    ASSERT(((ccount + 1) == h->nmatches) && "Number of matches do not match (...)");
    h->matches = mutt_mem_calloc(h->nmatches, sizeof(*h->matches));
#else
    h->re = mutt_mem_calloc(1, sizeof(*h->re));
    const int rc = regcomp(h->re, h->str, REG_EXTENDED);
    ASSERT(rc == 0 && "Fix your RE");
    h->matches = mutt_mem_calloc(h->nmatches, sizeof(*h->matches));
#endif
  }
  return h;
diff --git a/mutt/regex.c b/mutt/regex.c
@@ @@
{
  if (!str || (*str == '\0'))
    return NULL;
  struct Regex *rx = mutt_mem_calloc(1, sizeof(struct Regex));
  rx->pattern = mutt_str_dup(str);
  rx->regex = mutt_mem_calloc(1, sizeof(regex_t));
  if (REG_COMP(rx->regex, str, flags) != 0)
    mutt_regex_free(&rx);

@@ @@
    return NULL;

  uint16_t rflags = 0;
  struct Regex *reg = mutt_mem_calloc(1, sizeof(struct Regex));

  reg->regex = mutt_mem_calloc(1, sizeof(regex_t));
  reg->pattern = mutt_str_dup(str);

  /* Should we use smart case matching? */
@@ @@
 */
struct RegexNode *mutt_regexlist_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct RegexNode));
}

/**
@@ @@
 */
struct Replace *mutt_replacelist_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Replace));
}

/**
diff --git a/mutt/slist.c b/mutt/slist.c
@@ @@
 */
struct Slist *slist_new(uint32_t flags)
{
  struct Slist *list = mutt_mem_calloc(1, sizeof(*list));
  list->flags = flags;
  STAILQ_INIT(&list->head);

@@ @@
  else if ((flags & D_SLIST_SEP_MASK) == D_SLIST_SEP_COLON)
    sep = ':';

  struct Slist *list = mutt_mem_calloc(1, sizeof(struct Slist));
  list->flags = flags;
  STAILQ_INIT(&list->head);

diff --git a/mutt_thread.c b/mutt_thread.c
@@ @@
 */
struct ThreadsContext *mutt_thread_ctx_init(struct MailboxView *mv)
{
  struct ThreadsContext *tctx = mutt_mem_calloc(1, sizeof(struct ThreadsContext));
  tctx->mailbox_view = mv;
  return tctx;
}
@@ @@
  top = thread;

  array_size = 256;
  array = mutt_mem_calloc(array_size, sizeof(struct MuttThread *));
  while (true)
  {
    if (init || !thread->sort_thread_key || !thread->sort_aux_key)
@@ @@
      {
        tnew = (c_duplicate_threads ? thread : NULL);

        thread = mutt_mem_calloc(1, sizeof(struct MuttThread));
        thread->message = e;
        thread->check_subject = true;
        e->thread = thread;
@@ @@
      }
      else
      {
        tnew = mutt_mem_calloc(1, sizeof(struct MuttThread));
        mutt_hash_insert(tctx->hash, ref->data, tnew);
      }

diff --git a/mview.c b/mview.c
@@ @@
  if (!m)
    return NULL;

  struct MailboxView *mv = mutt_mem_calloc(1, sizeof(struct MailboxView));

  mv->notify = notify_new();
  notify_set_parent(mv->notify, parent);
diff --git a/mx.c b/mx.c
@@ @@
  }
  else
  {
    m->emails = mutt_mem_calloc(req_size, sizeof(struct Email *));
    m->v2r = mutt_mem_calloc(req_size, sizeof(int));
  }

  for (int i = m->email_max; i < req_size; i++)
diff --git a/ncrypt/crypt_gpgme.c b/ncrypt/crypt_gpgme.c
@@ @@
{
  struct CryptKeyInfo *k = NULL;

  k = mutt_mem_calloc(1, sizeof(*k));
  k->kobj = key->kobj;
  gpgme_key_ref(key->kobj);
  k->idx = key->idx;
@@ @@
    n++; /* delimiter or end of string */
  }
  n++; /* make sure to allocate at least one byte */
  p = mutt_mem_calloc(1, n);
  pattern = p;
  STAILQ_FOREACH(np, list, entries)
  {
@@ @@
    if (n == 0)
      goto no_pgphints;

    char **patarr = mutt_mem_calloc(n + 1, sizeof(*patarr));
    n = 0;
    STAILQ_FOREACH(np, hints, entries)
    {
@@ @@

      for (idx = 0, uid = key->uids; uid; idx++, uid = uid->next)
      {
        k = mutt_mem_calloc(1, sizeof(*k));
        k->kobj = key;
        gpgme_key_ref(k->kobj);
        k->idx = idx;
@@ @@

      for (idx = 0, uid = key->uids; uid; idx++, uid = uid->next)
      {
        k = mutt_mem_calloc(1, sizeof(*k));
        k->kobj = key;
        gpgme_key_ref(k->kobj);
        k->idx = idx;
@@ @@
    int idx;
    for (idx = 0, uid = key->uids; uid; idx++, uid = uid->next)
    {
      k = mutt_mem_calloc(1, sizeof(*k));
      k->kobj = key;
      gpgme_key_ref(k->kobj);
      k->idx = idx;
diff --git a/ncrypt/crypt_mod.c b/ncrypt/crypt_mod.c
@@ @@
 */
void crypto_module_register(const struct CryptModuleSpecs *specs)
{
  struct CryptModule *module = mutt_mem_calloc(1, sizeof(struct CryptModule));
  module->specs = specs;
  STAILQ_INSERT_HEAD(&CryptModules, module, entries);
}
diff --git a/ncrypt/gnupgparse.c b/ncrypt/gnupgparse.c
@@ @@

        mutt_debug(LL_DEBUG2, "user ID: %s\n", NONULL(p));

        uid = mutt_mem_calloc(1, sizeof(struct PgpUid));
        fix_uid(p);
        uid->addr = mutt_str_dup(p);
        uid->trust = trust;
diff --git a/ncrypt/pgplib.c b/ncrypt/pgplib.c
@@ @@

  for (; up; up = up->next)
  {
    *lp = mutt_mem_calloc(1, sizeof(struct PgpUid));
    (*lp)->trust = up->trust;
    (*lp)->flags = up->flags;
    (*lp)->addr = mutt_str_dup(up->addr);
diff --git a/ncrypt/smime.c b/ncrypt/smime.c
@@ @@

  struct SmimeKey *copy = NULL;

  copy = mutt_mem_calloc(1, sizeof(struct SmimeKey));
  copy->email = mutt_str_dup(key->email);
  copy->hash = mutt_str_dup(key->hash);
  copy->label = mutt_str_dup(key->label);
@@ @@
  char *pend = NULL, *p = NULL;
  int field = 0;

  struct SmimeKey *key = mutt_mem_calloc(1, sizeof(struct SmimeKey));

  for (p = buf; p; p = pend)
  {
@@ @@
  if (copy && buffer && num)
  {
    (*num) = count;
    *buffer = mutt_mem_calloc(count, sizeof(char *));
    count = 0;

    rewind(fp_out);
@@ @@
      size_t len = mutt_str_len(email);
      if (len && (email[len - 1] == '\n'))
        email[len - 1] = '\0';
      (*buffer)[count] = mutt_mem_calloc(mutt_str_len(email) + 1, sizeof(char));
      strncpy((*buffer)[count], email, mutt_str_len(email));
      count++;
    }
diff --git a/nntp/adata.c b/nntp/adata.c
@@ @@
 */
struct NntpAccountData *nntp_adata_new(struct Connection *conn)
{
  struct NntpAccountData *adata = mutt_mem_calloc(1, sizeof(struct NntpAccountData));
  adata->conn = conn;
  adata->groups_hash = mutt_hash_new(1009, MUTT_HASH_NO_FLAGS);
  mutt_hash_set_destructor(adata->groups_hash, nntp_hashelem_free, 0);
diff --git a/nntp/edata.c b/nntp/edata.c
@@ @@
 */
struct NntpEmailData *nntp_edata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct NntpEmailData));
}

/**
diff --git a/nntp/newsrc.c b/nntp/newsrc.c
@@ @@
    while (*b)
      if (*b++ == ',')
        j++;
    mdata->newsrc_ent = mutt_mem_calloc(j, sizeof(struct NewsrcEntry));
    mdata->subscribed = subs;

    /* parse entries */
@@ @@
  if (!entries)
  {
    entries = 5;
    mdata->newsrc_ent = mutt_mem_calloc(entries, sizeof(struct NewsrcEntry));
  }

  /* Set up to fake initial sequence from 1 to the article before the
@@ @@
  int rc = -1;

  size_t buflen = 10240;
  char *buf = mutt_mem_calloc(1, buflen);
  size_t off = 0;

  /* we will generate full newsrc here */
@@ @@
    return 0;

  size_t buflen = 10240;
  char *buf = mutt_mem_calloc(1, buflen);
  snprintf(buf, buflen, "%lu\n", (unsigned long) adata->newgroups_time);
  size_t off = strlen(buf);

@@ @@
  mdata->subscribed = true;
  if (!mdata->newsrc_ent)
  {
    mdata->newsrc_ent = mutt_mem_calloc(1, sizeof(struct NewsrcEntry));
    mdata->newsrc_len = 1;
    mdata->newsrc_ent[0].first = 1;
    mdata->newsrc_ent[0].last = 0;
diff --git a/nntp/nntp.c b/nntp/nntp.c
@@ @@
  fc.first = first;
  fc.last = last;
  fc.restore = restore;
  fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));
  if (!fc.messages)
    return -1;
  fc.hc = hc;
@@ @@
    const long c_nntp_context = cs_subset_long(NeoMutt->sub, "nntp_context");
    if (c_nntp_context && ((mdata->last_message - first + 1) > c_nntp_context))
      first = mdata->last_message - c_nntp_context + 1;
    messages = mutt_mem_calloc(mdata->last_loaded - first + 1, sizeof(unsigned char));
    hc = nntp_hcache_open(mdata);
    nntp_hcache_update(mdata, hc);
#endif
diff --git a/notmuch/adata.c b/notmuch/adata.c
@@ @@
 */
struct NmAccountData *nm_adata_new(void)
{
  struct NmAccountData *adata = mutt_mem_calloc(1, sizeof(struct NmAccountData));

  return adata;
}

/**
diff --git a/notmuch/complete.c b/notmuch/complete.c
@@ @@
    goto done;

  /* Get all the tags. */
  const char **nm_tags = mutt_mem_calloc(tag_count_1, sizeof(char *));
  if ((nm_get_all_tags(m_cur, nm_tags, &tag_count_2) != 0) || (tag_count_1 != tag_count_2))
  {
    completion_data_free_match_strings(cd);
diff --git a/notmuch/edata.c b/notmuch/edata.c
@@ @@
 */
struct NmEmailData *nm_edata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct NmEmailData));
}

/**
diff --git a/notmuch/mdata.c b/notmuch/mdata.c
@@ @@
  if (!url)
    return NULL;

  struct NmMboxData *mdata = mutt_mem_calloc(1, sizeof(struct NmMboxData));
  mutt_debug(LL_DEBUG1, "nm: initialize mailbox mdata %p\n", (void *) mdata);

  const short c_nm_db_limit = cs_subset_number(NeoMutt->sub, "nm_db_limit");
diff --git a/pager/display.c b/pager/display.c
@@ @@
      memset(&((*lines)[ch]), 0, sizeof(struct Line));
      (*lines)[ch].cid = -1;
      (*lines)[ch].search_arr_size = -1;
      (*lines)[ch].syntax = mutt_mem_calloc(1, sizeof(struct TextSyntax));
      ((*lines)[ch].syntax)[0].first = -1;
      ((*lines)[ch].syntax)[0].last = -1;
    }
@@ @@
      }
      else
      {
        cur_line->search = mutt_mem_calloc(1, sizeof(struct TextSyntax));
      }
      pmatch[0].rm_so += offset;
      pmatch[0].rm_eo += offset;
diff --git a/pager/dlg_pager.c b/pager/dlg_pager.c
@@ @@
  //---------- initialize redraw pdata  -----------------------------------------
  pview->win_pager->size = MUTT_WIN_SIZE_MAXIMISE;
  priv->lines_max = LINES; // number of lines on screen, from curses
  priv->lines = mutt_mem_calloc(priv->lines_max, sizeof(struct Line));
  priv->fp = mutt_file_fopen(pview->pdata->fname, "r");
  priv->has_types = ((pview->mode == PAGER_MODE_EMAIL) || (pview->flags & MUTT_SHOWCOLOR)) ?
                        MUTT_TYPES :
@@ @@
  {
    priv->lines[i].cid = -1;
    priv->lines[i].search_arr_size = -1;
    priv->lines[i].syntax = mutt_mem_calloc(1, sizeof(struct TextSyntax));
    (priv->lines[i].syntax)[0].first = -1;
    (priv->lines[i].syntax)[0].last = -1;
  }
diff --git a/pager/pbar.c b/pager/pbar.c
@@ @@
static struct PBarPrivateData *pbar_data_new(struct IndexSharedData *shared, struct PagerPrivateData *priv)
{
  struct PBarPrivateData *pbar_data = mutt_mem_calloc(1, sizeof(struct PBarPrivateData));

  pbar_data->shared = shared;
  pbar_data->priv = priv;
diff --git a/pager/private_data.c b/pager/private_data.c
@@ @@
 */
struct PagerPrivateData *pager_private_data_new(void)
{
  struct PagerPrivateData *priv = mutt_mem_calloc(1, sizeof(struct PagerPrivateData));

  priv->notify = notify_new();

diff --git a/pattern/compile.c b/pattern/compile.c
@@ @@
  }
  else
  {
    pat->p.regex = mutt_mem_calloc(1, sizeof(regex_t));
#ifdef USE_DEBUG_GRAPHVIZ
    pat->raw_pattern = mutt_str_dup(buf->data);
#endif
@@ @@
 */
static struct Pattern *mutt_pattern_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct Pattern));
}

/**
@@ @@
 */
static struct PatternList *mutt_pattern_list_new(void)
{
  struct PatternList *h = mutt_mem_calloc(1, sizeof(struct PatternList));
  SLIST_INIT(h);
  struct Pattern *p = mutt_pattern_new();
  SLIST_INSERT_HEAD(h, p, entries);
diff --git a/pattern/dlg_pattern.c b/pattern/dlg_pattern.c
@@ @@
    num_entries++;
  /* Add three more hard-coded entries */
  num_entries += 3;
  struct PatternEntry *entries = mutt_mem_calloc(num_entries, sizeof(struct PatternEntry));

  struct Menu *menu = dlg->wdata;
  menu->make_entry = pattern_make_entry;
diff --git a/pattern/search_state.c b/pattern/search_state.c
@@ @@
 */
struct SearchState *search_state_new(void)
{
  struct SearchState *s = mutt_mem_calloc(1, sizeof(struct SearchState));
  s->string = buf_pool_get();
  s->string_expn = buf_pool_get();
  return s;
diff --git a/pop/adata.c b/pop/adata.c
@@ @@
 */
struct PopAccountData *pop_adata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct PopAccountData));
}

/**
diff --git a/pop/edata.c b/pop/edata.c
@@ @@
 */
struct PopEmailData *pop_edata_new(const char *uid)
{
  struct PopEmailData *edata = mutt_mem_calloc(1, sizeof(struct PopEmailData));
  edata->uid = mutt_str_dup(uid);
  return edata;
}
diff --git a/pop/pop.c b/pop/pop.c
@@ @@
  int last = 0, msgs, bytes, rset = 0, rc;
  struct ConnAccount cac = { { 0 } };

  char *p = mutt_mem_calloc(strlen(c_pop_host) + 7, sizeof(char));
  char *url = p;
  if (url_check_scheme(c_pop_host) == U_UNKNOWN)
  {
diff --git a/progress/wdata.c b/progress/wdata.c
@@ @@
 */
struct ProgressWindowData *progress_wdata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct ProgressWindowData));
}

/**
diff --git a/score.c b/score.c
@@ @@
      FREE(&pattern);
      return MUTT_CMD_ERROR;
    }
    ptr = mutt_mem_calloc(1, sizeof(struct Score));
    if (last)
      last->next = ptr;
    else
diff --git a/send/header.c b/send/header.c
@@ @@
      break;
  }

  struct ListNode **ref = mutt_mem_calloc(length, sizeof(struct ListNode *));

  // store in reverse order
  size_t tmp = length;
diff --git a/send/send.c b/send/send.c
@@ @@
  mutt_parse_mime_message(e, msg->fp);
  mutt_message_hook(m, e, MUTT_MESSAGE_HOOK);

  actx = mutt_mem_calloc(1, sizeof(*actx));
  actx->email = e;
  actx->fp_root = msg->fp;

diff --git a/sidebar/sidebar.c b/sidebar/sidebar.c
@@ @@
   * they're valid, our pointers will be updated in prepare_sidebar() */

  struct IndexSharedData *shared = wdata->shared;
  struct SbEntry *entry = mutt_mem_calloc(1, sizeof(struct SbEntry));
  entry->mailbox = m;

  if (wdata->top_index < 0)
diff --git a/sidebar/wdata.c b/sidebar/wdata.c
@@ @@
 */
struct SidebarWindowData *sb_wdata_new(struct MuttWindow *win, struct IndexSharedData *shared)
{
  struct SidebarWindowData *wdata = mutt_mem_calloc(1, sizeof(struct SidebarWindowData));
  wdata->win = win;
  wdata->shared = shared;
  ARRAY_INIT(&wdata->entries);
diff --git a/store/bdb.c b/store/bdb.c
@@ @@
 */
static struct BdbStoreData *bdb_sdata_new(void)
{
  struct BdbStoreData *sdata = mutt_mem_calloc(1, sizeof(struct BdbStoreData));

  buf_alloc(&sdata->lockfile, 128);

diff --git a/store/lmdb.c b/store/lmdb.c
@@ @@
 */
static struct LmdbStoreData *lmdb_sdata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct LmdbStoreData));
}

/**
diff --git a/store/rocksdb.c b/store/rocksdb.c
@@ @@
 */
static struct RocksDbStoreData *rocksdb_sdata_new(void)
{
  return mutt_mem_calloc(1, sizeof(struct RocksDbStoreData));
}

/**
diff --git a/test/account/account_free.c b/test/account/account_free.c
@@ @@
  }

  {
    struct Account *a = mutt_mem_calloc(1, sizeof(*a));
    account_free(&a);
    TEST_CHECK_(1, "account_free(&a)");
  }

  {
    struct Account *a = mutt_mem_calloc(1, sizeof(*a));
    a->adata = mutt_mem_calloc(1, 32);
    a->adata_free = adata_free;

    account_free(&a);
diff --git a/test/buffer/buf_alloc.c b/test/buffer/buf_alloc.c
@@ @@
  }

  {
    struct Buffer *buf = mutt_mem_calloc(1, sizeof(struct Buffer));
    buf_alloc(buf, 10);
    TEST_CHECK_(1, "buf_alloc(buf, 10)");
    buf_free(&buf);
@@ @@

    for (size_t i = 0; i < mutt_array_size(sizes); i++)
    {
      struct Buffer *buf = mutt_mem_calloc(1, sizeof(struct Buffer));
      buf_alloc(buf, orig_size);
      TEST_CASE_("%d", sizes[i][0]);
      buf_alloc(buf, sizes[i][0]);
diff --git a/test/email/email_header_find.c b/test/email/email_header_find.c
@@ @@
  char *header = "X-TestHeader: 123";

  struct ListHead hdrlist = STAILQ_HEAD_INITIALIZER(hdrlist);
  struct ListNode *n = mutt_mem_calloc(1, sizeof(struct ListNode));
  n->data = mutt_str_dup(header);
  STAILQ_INSERT_TAIL(&hdrlist, n, entries);

diff --git a/test/email/email_header_update.c b/test/email/email_header_update.c
@@ @@
  const char *existing_header = "X-Found: foo";
  const char *new_value = "X-Found: 3.14";

  struct ListNode *n = mutt_mem_calloc(1, sizeof(struct ListNode));
  n->data = mutt_str_dup(existing_header);

  {
diff --git a/test/list/common.c b/test/list/common.c
@@ @@

  for (size_t i = 0; items[i]; i++)
  {
    struct ListNode *np = mutt_mem_calloc(1, sizeof(struct ListNode));
    if (copy)
      np->data = mutt_str_dup(items[i]);
    else
diff --git a/test/mailbox/mailbox_free.c b/test/mailbox/mailbox_free.c
@@ @@
  }

  {
    struct Mailbox *m = mutt_mem_calloc(1, sizeof(*m));
    mailbox_free(&m);
    TEST_CHECK_(1, "mailbox_free(&m)");
  }

  {
    struct Mailbox *m = mutt_mem_calloc(1, sizeof(*m));
    m->mdata = mutt_mem_calloc(1, 32);
    m->mdata_free = mdata_free;

    mailbox_free(&m);
diff --git a/test/neo/neomutt_free.c b/test/neo/neomutt_free.c
@@ @@
  }

  {
    struct NeoMutt *n = mutt_mem_calloc(1, sizeof(*n));
    neomutt_free(&n);
    TEST_CHECK_(1, "neomutt_free(&n)");
  }
