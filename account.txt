test sample configs with Valgrind, ASAN, UBSAN, Coverity

rename sub to cfg?  clearer meaning?

Context - paths, counts
Header[] list -> Env, Body, etc
Incoming -> MaiboxList[] (paths, counts)
MaiboxList 1/mailbox
no concept of account
Incoming becomes Account list
Account: imap server, maildir, notmuch, nntp?
account list: imap1, imap2, notmuch
Account named
who owns the context?
where is the config attached?

Account1
	mailbox[] (nested?)
Account2
	mailboxes
Account3
	mailboxes

62 functions use the context
22 functions use incoming

Context
Connection
Account
Mailbox
ConfigSet

Each host needs private data

NeoMutt - Config/globals
	Account (default)
	Account (specific)
		imap, pop, maildir, notmuch, etc
		Mailboxes (ref counted)
			Emails (ref counted) (Header, env, body, etc)

Account data private
	mxops

Where do patterns, limits, tagging live?
	On context (a mailbox *view*?)

Who uses Context, when a Account/Mailbox would do?

Context is a *view* of a mailbox
	who owns the views?

Mailbox should own headers, etc
	(id|subj|label) hashes

View has thread, tree/sorting data
Who owns Accounts?
	global to start with
	AccIncoming

Account
	IMAP 1 server/port/user combo
	POP 1 server/port/user combo
	Maildir user configurable set of folders (mailboxes)
	NNTP 1 server/port/user combo
	Notmuch 1 notmuch database

data, free_cb() + some fields common to all, name
Where do unsubscribed folders live?
not all Account's mailboxes are visible (subscribed/in sidebar)
Acc needs inherited config info -> separate object?
Config/Account -> Local Config
unaccount - closes connection, mailboxes, etc

Auto Accounts - Imap, pop, notmuch, nntp
how does 'account' command fit in?
mailboxes -> current 'account' NO -> default, YES use it
none -> 1 Account  incoming underneath
full auto -> find_ac(folder) -> folder not enough
	need user, host, port
account-ish config have user -> imap_user, what if they set A:imap_user?
account/set folder spoolfile, postponed, trash, record
use status bar to show their values, NO, not dynamic
need changed-account notification (account-hook) -> redraw
examples in 4 languages to highlight folder names (1 CJK)

NeoMutt object
	Config
	Connections
	Context
		Threads
	AccountList
		Account
			MailboxList
				EmailList
					Env, Body...

Mailboxes M
ask MXAPI for type of M
search As for owner?
or use A from config (if compatible)
or create new A (uniq name)
Add M to A

How does A test for M's membership?
*same* type (magic), $folder [user,host,port]
	login_cmp()
or mx_cmp() -- let *it* canonicalise $folder and compare login

Compare needs canon mailbox: have $folder, mailbox
path_canon($folder, mailbox) -> canon_mailbox
	NO needs login
pretty_path(A, ...) what's needed?
URL syntax:
	account://NAME/rel-path
or
	mailbox://ANAME/rel-path
or canon
	imaps://user@host:port/rel-path
abbreviate to:
	a:// or m://

Account NAME
set folder, imap user (pass)
mailboxes

folder could be '/', or empty or full path
X_{user,pass,login} -> {user,pass,login}
config name clash?
NO folder needs to be full else don't know which type the mailbox is

API mx_check_empty(path) -> bool - local use only
	or just open it?
API has_new_mail(path) - need to identify it first

∀ mailboxes - find by path, is notmuch, realpath, complex
	test empty, insert, remove, free

A is typed if all children are the same type, e.g. Notmuch

change functions to take a MailboxList (rather than a mailbox)
	UI creates list of one (for single selections)
	or a multiple for tagged
	thus centrlising tagging logic
	MailboxList or HeaderList

Header*View* is_tagged, etc can't be List
	needs to be sortable
	can we have *both*, Incoming and AccountList?
	How do I move Context inners to Mailbox?

Mailbox set, find -> obj + type
set trash = "x://path"
later resolve_mailbox($trash) -> lookup
find it, update ptr.  !found -> get type
Account -> Mailbox -> Email
path, (type?), Mailbox?

allow utf-8 account names?
	only forbid ':' scope separator
	store as punycode?
	store as b64-encoded?
	something to allow all characters

ac_get_str(A, IC_X) -> ptr to var
	what if someone changes it? crash!

have a magic Account for temporary mbox files?

when opening a folder from, what path string do we get?
	sidebar - full path
	browser - full path
	typed in - relative to current folder/account

C)ontext, A)ccount, M)ailbox, H)eader, T)hread

Move headers from C to M
	H array, ref-counted

C has Thread hashes (belong on M?)

Move C hdrs, but not v2r (that's *our* array)

First separate H from T?
	could we leave T in H to start?

Does the H need to know:
	a) it's in a T?
	b) which T it's in
	H Header no, UH User-Header YES

Does the UI want to work with UH which has T info, tagging, etc?

HV HeaderView
	C has HV[]
T is tree of HV (ptrs to H)
C needs to become MV (MailboxView)

Index, Pager wrt H
Who owns C, pass it down through functions

29 uses of Incoming
734 uses (82 functions using) Context

N -> AL -> NL -> EL (HEB, etc)

V)iew
L)ist

Index (MV), Pager (EV), Sidebar(AV) - viewers

MV has M, EL (subset of M's)
EL node (tagged, deleted, etc), sort
EV has E, cahced text, colour info, view info
AV has AL (subset of N's) current A, M, sort info

base object for all has
	type
	refcount
	bool deleted (or similar)

sidebar
	AV - $acc_view, $sb_sort
	MV new-only, sort
	SB maintains: highlight/selection, window view

index
	MV one mailbox
	EV tagging, limit, sort, threading, current selection

Pager
	EV one email - local (per email settings)

Index fmt uses I's MV, EV?
Status bar uses I's MV info
Pager bar needs I's MV info for (email x of y)
	needs P's EV for subject, %age through email

mx_open() open and attach to (create if nec.) account
	NO already done
config -> account tree
open M, not ready, open A, open M
Open A notify, e.g. sidebar A(red) -> A(green)
Open M notify sb -> active M, Index clears
Get Es notify -> Index populates
	that's probably the index doing the work
Open E notify whom?

Can the status bar *not* exist - just run on notifications. NO!

A name
mailboxes x y z
set folder
set imap_user
set imap_pass
set spoolfile
set postponed
set trash
set imap_list_subscribed

need default A type unknown, unnamed

'account' named A, type unknown [CREATE-A] (to AL)
set folder -> local config (imap_user, pass, etc, too)
mailboxes x y z relative to local $folder [ADD-M] to (to A)
	=> type -> IMAP
if mailboxes other:// type add to default (one type / A)

M has ptr to A (needed for cfg, etc)
chdir to PATH -> as As for a match
	A.match against local $folder NO match -> fail
	search through existing M [ABCDE] subscribed
or
	create new M [G]
or
	browser open / sidebar open

M: last update: never
A: state closed

mx_mbox_open(M) -> imap_acc_open (M -> A)
imap_acc_open(A) -> socket, conn stuff
	get mailboxes? if so, update statuses of Ms
	M: UNPOP, POPULATED, NOT_EXIST - notify
open(M) -> imap_mbox_open(M)
	if (!exist) error
	if (POPULATED) done
UNPOPULATED
	get email IDs; notify (may be in hcache)

"open" is too wide: need
	list new
	list all
	get headers (list)
	get struct (list)
	get body (list)

get headers -> EL
	each with state
	HEADER -> notify
	get in reverse order (newest first)?

notifications on ...?
	N, A, M, E with recursive flag

Index watches M+ (recursive)
Pager watches E
Sidebar N+

Events NEW, CHANGED, DELETED

Do objects need an IWatchable interface?
	tough for the N object (not refcounted)

backends:
	imap, pop, maildir(mh), mbox(mmdf), nntp, notmuch, compressed

ctx->data: pop, nntp, imap, mh, nm,
hdr->data: nntp, nm, imap, pop (idstr)

1 empty A per M if no <account>

struct naming?
	VMailbox (view)
	LAccount (list)

abstract the mailbox?
	add/remove()
	find_by_id()
	find_by_path()
	keep count
	mbox -> array for views?

slab allocator / factory ∀ myriad small objects?

unify all private data {new,free,init,get}_X

multiple notifications: let the receivers know what's coming
	start(uniq id, expected count)
	count * notify()
	end(uniq id)
	receivers can ignore some as long as they listen for `end`

drop mailbox_free()?
	use mbox_close

create header_free() ∀ mailboxes

should we steal account-hook <set> commands NO
	POSSIBLY -- if we have a *named* account
	and a matching hook

∀ backend, mailboxes - no info existing M, existing A?

imap <mailboxes> imaps://apple.com/aardvark -> M
     <mailboxes> imaps://apple.com/beaver

empty new M, open -> new A done
$folder + <mb> - path -> dummy A, no name, no type
match -> attach, not -> create & attach
A has no config for backwards compat
<a><mb> apple banana -> 2*M -> A
A is incomplete, but has config
	set user,pass -> A
adding to A -> need sibling test?
how would that work for maildir?  can't NO
open M, have A has type,config, still run A-hook

open A

how do we list all of M?
0 named A -> iterate through ML as <mb>'d
1+ named A -> <a> used -> assume always
	iterate through AL, then ML

sb_sort = A:alpha,M:new,M:alpha
if A: missing, don't display -> only M? complicated
if A: missing, don't sort A at all
sb_display_account [LIST] of A

maildir: <mb> a b c (no A specified) use dummy?
open 'b' don't need A, so continue using dummy
dummy means *AL*, ML, always

maildir <a><mb> a b c  named A, grouped config
only create dummy when needed?
	simple case only 1 A
sb_display = A1,A2,A3
	empty => all
	+=, -=
	!= (toggle?)
no advantage to displaying nothing!
	turn off sidebar

nm A matched by db path - contents of A just <mb>
nntp A matched by user,pass,host -- all subscribed groups
nm - param to name query? -> desc or
	<sb-subscribe>
	<sb-desc-folder> / <sb-name-folder>
		to make it session-permanent

mailbox_free -> separation between close and free?
	needed?
close -> maybe a reopen
free -> DEAD forever

open on Imap A -> LSUB & <mb>

A types:
	MboxA - name, config, data (->conn)
	ConnA - user, pass, port, host, etc
	(cfg)A - config

Imap -> Connection (stacked), Mbox, Nntp too
maildir -> NULL, compresse too
notmuch -> db info

how much M->data can become A->data?
	A-data
	M-data
	E-data
data-free will close connections if nec

hcache is opened at parse time -- how long is it kept open?
keep as A-data, keep open? YES

change mh_data() to get_mh_data() -- so it isn't mistaken as a cast

E-data
	pop: uid
	nntp: article num
	imap: flags, uid
	nm: uid
	md: none (flags?)
	mbox: none
	comp: none

mxapi: create compare function which uses backend-specific id

check POP uid in hcache, refno too (meaning?)

mx_open(imap://) (no folder info)
find A -> need backends to do matching
take host, user, port ito account (net backends)
take dir into account (maildir)
	no A for md -> base dir of '/'

split up mxops into A, M, E versions
A:
	path*
	mbox_open*
	msg_padding
M:
	msg_open*
	mbox_check/sync/close
E:
	tags*? or M?
	msg_commit
	msg_close

do all X ops really want to happen on parent(X)?
	so that... what?
	notifications?
	client shouldn't know/care

M might cache tags on E
	but that knowledge should be private to backend
E has ptr to M
	*it* should do *that* work
close() on X, open on parent(X)?
	is this the exception?

who probes the first path?
	we don't have an A
have NULL A ∀ backends?
	A(NULL)->probe(path)
if probe isn't in mxapi, who has list of probes?
	does probe return an A?
		no, not enough info

how do the backends get access to Config?
	don't want to use a global
	need main Config ptr to create A-specific Config

------------------------------------------------------------

who owns AL?

int mx_mbox_open(M, flags);
	M partially filled Mailbox, requirements are backend-specific

int mx_mbox_open(AL, M, flags);
	backend doesn't need to keep any objects
	or need access to any globals (except its own)

------------------------------------------------------------

mailboxes a b c
	a,b siblings, c different
	create dummy A0
	create one M per path
		probe path to get TYPE
		attach to dummy A0

open M(b)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? NO
	find matching A: FAILED
	open A
		create A1 (unnamed, no config)
		connect to server
		populate A1
	populate M (using A1)

open M(a)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? NO
	find matching A: MATCHED - A1
		using user,pass,host,port
	populate M (using A1)

open M(c)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? NO
	find matching A: FAILED
	open A
		create A2 (unnamed, no config)
		connect to server
		populate A2
	populate M (using A2)

------------------------------------------------------------

account apple
mailboxes a1 a2 a3
	create ML with A=apple

open M(a1)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? YES
	is open? NO
	open A
		create A1 (unnamed, no config)
		connect to server
		populate A1
	populate M (using A1)

open M(a2)
	run A-hook (only set global config)
		needs to be run by mx.c
	has real A? YES
	is open? YES
	populate M (using A1)

mbox check_all should happen at A-level (for efficiency)

config: use synonyms and inheritance for A:user -> imap_user mapping?

--------------------------------------------------------------------------------

parse_mailboxes

nm_path_probe, nm_normalize_uri
mutt_expand_path(_regex)
imap_path_probe
	imap_expand_path
	imap_parse_path
	imap_conn_find
	mutt_conn_find
	mutt_account_hook
mx_path_canon (^-expansion)
	mx_path_probe -> path_canon
nm_path_probe
mx_path_probe
mx_path_probe

--------------------------------------------------------------------------------

mailboxes + folder -> Mailbox
	expand using $folder, $HOME
	if expansion fails, mailbox is errored and dropped
	backend may use "user", "login", "pass"
DON'T search for A, or attach an A
=> Mailbox (partial)
NO user, login, pass info lost => NEED A
=> find_A with partial info
reason for Username, ImapUser checks (account_match)

imap://user:pass@host:port/path

when matching mailboxes should search in reverse order
(most recently defined matching mailbox wins)

store login, user, pass on A, give ptr to Connection (shorter-lived)

auto A mailboxes:
	imap: LSUB subscribed
	nntp: newsrc
	maildir: how? flat search, or recursive option?
	notmuch: how? saved/pre-defined queries - how to we get them?

--------------------------------------------------------------------------------

mailboxes +name

expand using $folder, $HOME (or die) => Mailbox (partial)
find_A(M) or mx_find_A(M) -> mx_new_A(M?)
	flag for new?  when else will we need a new A?
new_A creates A and adata - need new for *name* of A
backends might have different Config overrides

--------------------------------------------------------------------------------

Mailboxes - new uses for path, realpath
	rename realpath to canon_path - contents BE-specific
if !A then path = canon_path, except for compressed
if A, then canon_path is canonical and path is pretty
	relative to A-$folder (except compressed)
Internally convert =folder to +folder?
A_find_M(path) uses global AL (for now)

Does imap canon path contain user,pass,login,port?
	if there's a specific imap_find(), then no (only if A)
	what do we display to the user?
	what if two M differ only by user?

Account syntax?  A-name +folder - apple:+folder
	should *this* be shared in path?  ON
	if folder is in root of A-apple, then apple:folder is ok
	":+folder" relative to current M/A, equiv to "+folder"

canon path - "user" always, "pass" never, "login" if set, "port" if non-standard
	A-$folder set to /a/b or imap://a/b - stored as what?
	login info stored in A->data.conn
	$folder stored in A->config
		accept /a/b store as imap://a/b

expandos for canon_path, pretty_path, A-name too
	short_canon too? no (user,login,port) or make canon expando smart?
	when creating a new A, check others to determine which attributes
		make a path canonical (user,login,port) -- NO confusing

Mailbox/mbox path = user entered path, tidied up
	canon_path = realpath() of path

pop/nntp like imap
notmuch - path nm://query
	realpath include db path

WON'T be a !A (it'll always be present) only an UNNAMED A

--------------------------------------------------------------------------------

mailboxes X
	(relative|canon)
	A(exists|missing)
	account cmd?

1)
	canon(X)
	probe(X) => magic, ops

2)
	if (A.cmd) use A
	if (BE->find_A(X)) use A
	else BE->create_A(NULL)

3)
	BE->find(A,X) -> M
		error exists
	else BE->create_M(X) -> success
	ac_add(A,M)

mx functions?
	account_find(path)
	mbox_create(path)
	ac_add(A,M)
	ac_remove(A,M)

ac_function - names clash with Config
ac functions above mbox functions in API

"account apple" - don't know typ until "mailboxes"
if current A, close existing?  NO
or have mx_ac_free(A)? NO

account_create(name) -> A(empty)

--------------------------------------------------------------------------------

mbox_create(path, canon, magic)
	set magic, path, realpath

ac_create(name) set name, init config (no name => set neither)
ac_create(path) NO, ac_add(M) instead

ac_add(A,M) -> A check/set type, add M, link objs
ac_remove(A,M) -> unlink, remove M
ac_find(A, path) ∀ M do BE-specific M-compare(M, path)

who add A to BE list?  when?
	ac_add(A,M)?

does BE need a private list?
	not to start with

do we need Connections?  they're not shared between BEs
have a 1s timer call to all BEs
	let them implement keepalive, etc
save escaped (munged) imap mboxname in Mailbox->data (priv)

mx_mbox_find(path, flags)
uses Folder to expand // probe to identify(delegated to BE)
or A_find_mbox(path, flags, **M, **A)
returns M or new M or NULL
should it create M?
should it create A?
should it *open* A?

how many functions can be called 'cold' with just a path?
	few?  1  change_folder()
create_mailbox(have A)
2 routes
	notmuch
		entire-thread -- new mbox
		vf-from-query -- possible new mbox
		window-back -- alter existing mbox and refresh
		window-forward -- same
	other folder
		change-folder
nntp -> existing mbox, or not
	what if A doesn't exist?

mbox_open ->
	first find and refresh
	else find A and open
	else open A, open M

do we need *A* check for new mail?  we'll already
	or by A then M.  if A_check succeeds, next A, else ∀ M
imap sends separate STATUS.  any advantage to A_check?
(over n*M_check)?  sorting?

maildir A - unnamed => root is /
	named - who sets root? when?
account apple [ARGS] -- passed to ac_create?
	interferes with one-liner account NAME commands
set folder = /x/y - trap this?  and set root?  how?

when we A_add_M(M) select root?
	if named, what do we select?
what's the root of each BE?  (named vs unnamed)?
pop,imap,nntp - (host,user,port) (named or unnamed)
mbox,compressed - fixed, so irrelevant -- 1 M per A
notmuch - db - fixed
maildir
	unnamed -> root is /
	named but no A-$folder -> root is /
	named and A-$folder -> root is A-$folder

sidebar_account=X,Y,Z
	missing accounts not hidden, just collapsed?
or sidebar_collapsed=X,Y,Z

dropping "imap_" means $folder MUST come first
	else we don't know the BE type

when we 'c'hange folder and <tab> complete
	can we preserve M (as we know it)

--------------------------------------------------------------------------------

MAILDIR
	set folder=/x
	mailboxes =y

1) no A, no M
2) A, diff M
3) A, same M

1) (canon, probe), wrap in M, find A, create A, add M to A
2) (canon, probe), find A, find M, wrap in M, add M to A
3) (canon, probe), find A, find M

Need to canon? NO just expand $folder NO
then probe for magic
∀ A call A_match_path(P) -> need canon

16 calls to mx_mbox_open - most know M (or can find it)
int mx_mbox_open(M*, flags) NO parse_mailboxes

if (!canon) canon(M), sets magic }
if (!magic) probe(M), sets magic }- move it inside functions
mx_find_A(M) 1) NULL, 2,3) A

1) create A(magic), set A's magic
2,3) A_find_M(M)  2) NULL  3) M
2) A_add_M(M)

mx_find_A(M)  use magic, call BE->A_path_match(M->canon)
M = A_find_M(A, M)  ∀ A.ML use BE cmp, do what on match?
A_add_M(A, M) add M to A.ML, set links

A_find_M(A,M*) -> error, no match make replaces M

--------------------------------------------------------------------------------

move mxops to A?
most ops need M, not ctx.  ctx is a view for UI only

canon includes decorations: imap://user@
	path is just server-local path

move all dot_dump nec headers to BE_private.h

change backing for config vars:
	$mbox, $postponed, $record, $spoolfile, $trash
	what about $folder?
	to type Mailbox
	need new config type
	find/create M, attach to A
	how do M's build deps fit in with Config?

attach smtp Connection to NeoMutt object -> smtp_init(), smtp_shutdown()
	or does smtp belong at A level -- one per A, or global?
	$smtp_url, pass, authenticaors - A-specific

--------------------------------------------------------------------------------

path is user specified - what if they specify decorations?
real/canon doesn't exist M-specific (possibly split up)
M comparisons done by BE
path completely undecorated -> use "named" mailboxes if not suitable
with IMAP delim of '.' should the path be '/' delimited? for ease of other code
path is tidied and undecorated
what about full path for status bar -- need realpath + decorations
path relative to root
canon - fully qualified & real, fully decorated (excluding default ports, etc)

--------------------------------------------------------------------------------

standard functions ∀ BE
	vars: adata, mdata, edata
	fns: BE_DATA_{free,new,get} (in this order)
	vars: a Account, m Mailbox, e Email, ctx Context (will be mv)
	@extends ∀ Xdata

create an A-check ∀ notmuch M => one db open, close
view obj automatically watches data obj
struct Mailbox *m ∀ src
adata and mdata should be private!
BE_separate msg, hcache srcfile?  what else?
	CurrentNewsSrv (kill this)
check all ac_find() work, multiple A ∀ BE
Connection's account info ptr *const*
Add Buffer ptr ∀ mxapi - aim to remove all mutt_error!
"INBOX" string 15 * in IMAP
revert '=' to '+' conversion?  option?
account-hooks not fired
eliminate "ImapMbox" - what's its use?
change conn_close to ** free
*imap* complete_hosts is effectively complete_A() ∀ BE?

--------------------------------------------------------------------------------

A-hook - when is it called?
	only on first M open - keep credentials
	just before adata_new()
folder-hook on every M
match against
	realpath
	path
	description
change A hook to take (M)
what does F-hook need?  same?
what about after M-close? or reconnect after conn loss?
so ∀ M open -> A-hook, F-hook  NO
only if actually need to reconnect - when?
BE_something() -> first check conn
	get_adata() -> (re-)open conn -> A-hook first

--------------------------------------------------------------------------------

option $dont_close - don't mbox_close on leaving
for check_all, do we need to run A-hook each time?
	only for lost connections

∀ BE_parse_path -> path -> ConnAcct - where?  add tests

pop_fetch_mail doesn't use Context - assumes 1 host
	if ctx, use it
	if !ctx fetch all pop hosts?
	if !PopHost - fetch all pop BE

only BE can set/change realpath(canon)
if path is undecorated, is path == realpath + strlen(imap://) ?
	not always - compressed BE will differ

A-config browser folder_format - per A?
	sort_browser too

A-config sidebar_format - per A?
	sb blocks?
	sorting?

--------------------------------------------------------------------------------

Mailbox Orphans

browser - store paths as Mailbox - need refcounting first

orphan M ∀ $paths like WeakPtr - resolve as needed
$folder, ^, etc resolved, then M is canon'd, has magic too
gets M ptr when ref-counted, A-ptr useful too (ref-counted)

orphans need listener (cs, he, name, ev)
	he is ConfigDef
orphans will rely on M->path being char* (not an array)
point orphan config vars to &M.path
	listener triggers probe, tidy, canon
	=> config doesn't need to know about M
listener needs to convert &M.path to &M where path may not be first member
	offsetof macro?
is orphan an M or a struct { path, M* }?
	can't be M, because it needs to be able to be NULL
	M*?  makes config setting awkward
	M is OK, because M.path can be NULL
flags = ORPHAN
all mxapi fns do
	M = orphan_resolve(M)

have
	M* (orphan) resolve
	M* (real) No A*

MV has WeakPtr (Orphan) to last used E
path_pretty -> path_tidy?
	just the path section of (real)path
	if imap:// then /, otherwise IMBOX?
parse_mailboxes -> path & realpath
folder-, account-hook -> realpath

M* path_wrap(P) p->path, canon(P), probe first, tidy(path)
account-hook canon, since matche to realpath (start)
	is canon needed?  OR BE-A-match?
	so that imap://host matches imap://user@host?
	NO, it's a regex

A for possibly non-existent M
	A* ac_find_account(P)
	that's mostly probe()

find specific M (e.g. resolve orphan)
	ac_find_mailbox(A, M) -> M2

should Orphan have A*?  YES, lifespan of A is large enough

path_match(M,P) or (P,P)
	which path?  realpath

mx_resolve_path(P) -> M(P, R, magic, A), orphan flag
	ac_add -> !orphan

how do orphans work with inherited config?

any M is final - don't canon/pretty/deconstruct it

mx_mbox_open_path() wrapper?

mx_mbox_open_path()
	Trash, Spoolfile or mbox-hook, user, Postponed, save path, tmpmbox, mainfolder
mx_mbox_open() 5 calls using Mailbox

store M as trees
BE knows how, frontend doesn't need to know
	get_M(A, flags) -> flat, tree, filtered, etc for MV

check all mxapi params are used, e.g. folder

user path - copy to M->realpath
	expand +
	canon(M) -> M->path ?

mxapi GUARANTEE
	check M->A is set ∀ M in AllMailboxes
	VALID(M) macro?
	∀ M
		M->A exists
		M->magic
		M->mxops
		M->path set and tidy
		M->realpath set (canon)
	ensure correct magic to match backend
	ensure ctx->M is valie

fine for $trash, $record, etc backed by M
	(only safe whtn A is ref-counted)
	what about hook paths?
	folder-hook regex against M->path
	account-hook regex against M->realpath (canon)

does M* resolve(P) find the *real* M, or create an orphan?
	might not exist, so orphan, but with A*

perhaps not "resolve", use that for Orphan -> M

M* identify(P), mx_identify(P)

mailbox.c
	eliminate AllMailboxes
	get_all_mailboxes(FLAT|TREE) -> ML

new M, P -> M -> r canon(M->r), or pass all to BE
M* BE_identify(P), path, canon, magic, A* (orphan, hidden)
identify is distinct from M* BE_resolve(M) (real M)
error conditions for identify()
	probe failed
	canon failed
	pretty failed (likely?)

updates from BE -- several emails deleted
	each sends a notification to EV (gui)
	EV NULLs ptr
	on next refresh, GUI is recalculated wrt missing emails
		open folds stay open
		closed folds stay closed

account: use $spoolfile to merge an inbox into the account line
	spoolfile not set
	AC_NAME
		inbox  1/6
		apple  2/7
		banana 3/8
	spoofile=inbox
	AC_NAME        1/6
		apple  2/7
		banana 3/8

Account
	Email children[];
	char *name;
	Account *next;

account [[name] mailbox]
	mailboxes
account

----

unaccount command
	A-specific config will be lost

aliases:
	mailbox,unmailbox for mailboxes,unmailboxes
	(no -es)

----

main -> index <-> pager
	       -> compose -> menu

<change-folder> (or equiv)
does Pager need Context?
	where? why?
	only needs Mailbox, Email
Context contained in Index only
	index-pager lines (who owns this?)
start index with (M), even from main?
nobody else needs to know - no need to be global
pass M (or Ctx) to children
if <change-folder>, close ctx and reopen
in pager <next-email> not relevant, close pager and reopen
change folder from pager -> close pager, then index close & reopen ctx
what about Email's gui parts - not a problem yet
other ctxs?  compose(attach), postpone(select)
	limited to those functions

----

2 views, e.g. Mailbox -> Context -> Attach Email
Two gui views of 1 Mailbox : View1, View2
readonly is a View attribute
V1 deletes M1, M2
v2 deletes M2, M3
V1 syncs, M1, M2 deleted
	V2 notified -> what happens?
		M1, M2 disappear?
		or wait for V2 sync? NO
		if M1 is deleted, we can't read it
Readonly - only relevant for Views
	for user-facing code

----

open readonly <Alt-C>
or compose, attach -> R/O
or neomutt -R

----

V1, modified
compose, etc
	attach msg -> new view V2
does new view show V1's changes?

if we had 2 views of one mailbox how do we know which
view is the 'current' when we start <compose>?

----

is APPEND a view flag? NO
	which BE's support APPEND?
	=> mbox_open_append()

who APPENDs? 7

	Function		acts on		is open
	trash_append()		[trash]		no
	mx_mbox_close()		[trash]		no
	mutt_save_message()	[folder]	possibly
	pop_fetch_mail()	[spool]		possibly
	mutt_write_fcc()	[fcc]		possibly
	mutt_save_attachment()	[folder]	possibly
	ev_message()		[folder]	yes

2nd compose attach message: where else?  ctx_open()

------------------------------------------------------------

(SF)	mutt_set_flag - 68
(ESF)	mutt_emails_set_flag - 8
(CF)	mutt_change_flag - 2 (index/pager)
(SFU)	mutt_set_flag_update - 3 (score)

ctx -> R/O <CF-ro>
M -> R/O immutable

D	Deleted
N	New
O	Old
R	Replied
*	Tagged
!	Flagged

----

index/pager -> CF -> ESF -> SF -> SFU [5]
	CF select DNOR*!
	RO only * available, others fail quietly
	<tag-prefix><set-flag> forbidden
	            <clear-flag>
	CHECK_READONLY

----

Index -> ESF -> SF -> SFU
	CHECK_READONLY
	CF -> ESF ... [3]

X	score_message -> SFU
mutt_sort_headers	ctx yes
ctx_update		ctx yes
mutt_check_rescore	called by Index
	after OP_ENTER_COMMAND

----

SF callers
index
	2 TAG
	6 CHECK_READONLY
pager
	1 READ
	8 CHECK_READONLY
	1 TAG
have ctx
	1 mutt_attach_reply REPLIED
	1 display_message READ
	3 save_message_ctx DEL,PURGE,TAG
	1 select_message DEL
	2 get_postponed DEL,PURGE

----

mx_mbox_close [3]
	move MUTT_OLD to ctx_close()?
	DEL,PURGE -> ctx_close() too?
	Business Logic Layer (BUS)
	BUS conflated with GUI atm

----

3 thread_set_flag
	7 index DEL,PURGE,READ,TAG
	5 pager DEL,PURGE,TAG
3 pattern_func DEL,PURGE,TAG
2 ci_send_message REPLIED

Tag only
	1 check_mailbox
	1 link_threads

----

ev_message NEEDS context
	DEL,PURGE,READ
	TAG

----

nntp_catchup [1]
	index CHECK_READONLY
	browser Context
	mx_mbox_close Context
	uncatchup [1]
	browser - Context

----

mx -> tags_commit - disallow in index
	-> notmuch [6]

mx -> mbox_check -> mbox [7]
	-> reopen_mbox
	-> set_flags

mx_mbox_sync()
mx_mbox_check() - not USER changes
	allow?  NO

maildir_update_flags
	nm_mbox_check(mx, sync)
	mh_mbox_check(mx, check/sync)

create N, perform all init()s, they observe(N)
init Config before init()s.  inits may add config, e.g. sidebar
inits ignore config setting. wait for NeoInitComplete
after inits, read config files, etc

create N, core init -> ConfigInit, core vars, sb init, etc
Xinit: reg types, reg vars, set vals, set observers - all configurable parts
configure option for disabled config - recognised but ignored
need to *register* commands, e.g. sb_whitelist
when do *functions* need to be registered/defined? <sb_open>
re (FN_PAGER, SB_OPEN) an array of fn defs, with default keys
*NEEDS* to be in init, so user can bind keys to them
sorted vector/arrays of commands/functions
	ptrs into static array

InitComplete -> enable observers YES, now read config
config -> mailboxes/accounts -> A's =>

"account home" -> A_new(), then N.add(A) -> notify new A
"mailboxes path" -> M_new(), canon/expand $folder
A.add(M) -> success -> notify new M
failure -> ac_find(M)
not found -> A_new(), N.add(A) -> notify new A
found mx_ac_add(A,M) -> A.add(M) -> notify new M

enum NotifyOBJECT
struct EventOBJECT

entry points ∀ events
main() : startup, config
main() -f mbox or $spoolfile, mx_mbox_open()
	mutt_index_menu
index OP_QUIT, shutdown-hook, mbox_close

config "account home" -> A_new(), N.add(A), <a-post-create>
"mailboxes path" -> M_new(), A.add(M), <m-post-create>

"mailboxes path" -> M_new() -> A_new(), N.add(A), <a-post-create)
	A.add(M), <m-post-create>

parse_account - (ac_find by name, ac_set_current), ac_new()
A might be temporary => N.add(A) -> <a-post-create>
"unaccount home" -> <a-pre-del>, N.del(a), free(A)
	=> ∀ M <m-pre-del>, A.del(M), free(M)

Hooks: black box
	21 hooks + unhook
	3 parse functions

account home ( -imap) ?
set imap_pass="secret"
mailboxes imap://...
can't be sure until mailboxes, can't insist it comes first
=> overfill to keep all config
when is A type defined?
auto & immediate for mailboxes imap://
delayed for "account home"
account could be cumulative
file1 "account home" config
file2 "account home" mailboxes
could end up with unspecified A at startup =>
	don't error or drop it
	more config could come later
	just ignore empty A's

what happens after "account home" source file
	end of included file will stop account-ness!
	need to stack, push name
	repeated "account" in one file shouldn't nest

account create empty A
mailboxes + empty A -> typed A
mailboxes + typed A -> OK
mailboxes + wrong A -> warning, new typed A
	is "account" still active after error? prob yes
	offer all M to active A, first
who adds sub Config?
	parse_mailboxes adds it
when
	when it becomes typed?
source nested - what about nested account commands
stack
	ac Apple
	source jim.rc -> Apple,Apple
	rc contains more accounts -> Apple,Banana
	EOF -> pop -> Apple
	continue

tests

	t00-legacy - mutt-compatible with hooks, etc
	t01-simple - account A, account B, account C in one file

lots of different but equivalent configs
including some degenerate ones

move test data to repo
	cars
	f1/fruit
	o1/o2/oceans
	t1/t2/t3/trees

$folder masks depth

---

Account docs

everything sounds better preceded by "account-specific"
rationale - reduce number of account-,folder-hooks
reduce config complexity for multiple accounts - in short maxim (above)

sample: two M on different A (imap) a-hooks, f-hooks
sample: with account command (indent for clarity)

account [ name [ config ] ]
	examples of each

"account" range - account empty, named, EOF

nested "source"d files inherit parent's "account"

implemented:
	done: mailboxes
	WIP: $folder, $index_formal
	planned: $imap_*, $maildir_*, all index config e.g. sorting
	long term: colours?  other hooks?, M-specific config?

a-hook: user/pass/etc, crypto, tunnel, etc

examples for grouping Maildir
	does this work on ONE imap account?
		make it work

---

warn of non-A config
warn of ill-matches Mailbox+Account combo

---

test double inheritance
	base - Account - Mailbox
	(no need for named-mailboxes!?)

relative dates script
	read email dates
	take latest as high-water mark
	rebase ∀ to NOW
	dir param -> all under
	files -> just them
	-d "base date" - relative to date

---

Inherited config

Base - Account - Mailbox

can be (re)set independently

test B(S,I); A(S,I); M(S,I)
	S = set
	I = initial or inherited
=> 8 tests, 3 values for each
∀ Base value == global var

8 reset tests
	set all, then reset
	3 value for each

all config objects might need altering to find *base* value for inheritance
test set_initial on B,A,M - meaning?  always most base?
	YES, only code and only during initialisation.
	only allow on Base

"mailbox" command "mailbox name" => named-mailboxes
	NO, no path
"mailbox [name [config]]"
	path command only valid in "mailbox" command?
or "mailbox name" only after "named-mailboxes" *defines* M?
"mailbox" extends to
	mailboxes empty, named, EOF or account command!

mailboxes name
	path XYZ
	set ABC
	(color ...)

is some config A-only, some M-only, some both A- and M-?
account credentials - clearly A-only, $folder too
$index_format could be Base, A- or M-specific
	=> there's no M-only config
	M ⊂ A

---

How is config used?

need A-VID and M-VID maybe
list of M-config comes first with M-VID, then A-conf, A-VID
don't want to expose A-conf on Mailbox
	=> need separate A-get_value() and M-get_value()

get_string(A->cs, A_VID)

named-mailboxes *defines* M-config?
	any point if not used? NO

if A-, M-config isn't defined how do we degrade gracefully?
	cs == NULL!  then what?
	M knows parent A
	A? => global Config

---

name	Base		Account		Mailbox
	HashElem	HashElem	HashElem
type	STRING		STR|INHERITED	STR|INHERITED
ptr	ConfigDef	Inheritance	Inheritance
backed	mutt_config.c	Base-HE		Account-HE
var	global		struct		struct

draw diagram

backends may use *their* globals directly. NO OTHERS
Notes: all inheritance happens in config/set.c
type source files are simple

how does "mailbox" naming work?
only allowed in "account"?
or must match "mailbox aname:mname"?
limits names to no whitespace
allow whitespace in names if escaped of quoted?
utf-8 too
just no colons

A has cs ptr, so all backends can be global-free
inherited A uses A->cs
inherited M uses M->parent->cs

backend: globals *only* for settings global to the entire driver
everything else is A- or M-specific
all config may start as global, but should become A- or M-specific

unaccount/unmailboxes need to *un*register inherited variables

*un*account before merging account
	inheritance fixes too

set completion for account/mailbox scoping
	acc:mbox:var

each backend/module registers variables
	but need to ref A-,M-specific config
	NO, VIDs would vary
	currently A needs to hard-code list of A-specific vars
	flag on ConfigDef?
	The each user would need to keep HashElem pointers for all the vars they want to use
	setup list at MODULE_init()
	what happens when mutt_config.c is split?
	IMAP, POP both require shared config vars
		what about the backing global variable?
		who owns it?
	reg_one_var() can't warn or error -- needs to be quiet

subset: add_config(cs, NULL) for A
	add_config(cs, A-Subset) for M
	parent name
	need parent ptr? or pass in name?

Do we need N-subset?
	Large! nearly 500 ptrs * 2 (8K)
	just so we can get_var(N-Sub), (A-Sub), (M-Sub)?
	majority of N-sub are read-only vars
		not worth it

cs_add_subset(cs, subset)
	subset contains full name
	A&M cannot be renamed
	A-Sub "acc", M-Sub "acc:mbox"
	get_var(A-Sub/M-Sub, Name/HE, VID)
	get_X(subset, VID)
	lookup(subset, name) how?
	if we have 'HE', use base config functions
	lookup if contains ':' use it, else prefix with sub.name
	search var_names, return VID, fixed for life of build

ultimately will all config become Subset-used?
	all cfg is abstract?

deep testing
	complex type - Address
	(initial, neo, acc, mailbox) versions
	create cs, destroy cs
	create cs, set val, destroy cs
	create A, create M, destroy M, destroy A
	create A, create M, set A, destroy M, destroy A
	create A, create M, set M, destroy M, destroy A
	create A, create M, set A, set M, destroy M, destroy A
	(no initial, initial)
	(no action, set val)
	NONE | N | A | M
	get A, set N, get A, reset N, get A, set A, get A

--------------------------------------------------------------------------------

Config

core (neomutt, e.g. gui)
modules (sidebar, imap, etc)
multi-level inheritance
central config?
split config?
config flagged for inheritance
reg(core); reg(imap); ...

inherit - fixed at build?  or dynamic at configure?
get_val("name") or
get_val(subset, "name") or
get_val(module, subset, "name")
module is just a ConfigSet NO
Account { Subset }, Mailbox { Subset }
NO, I'd need a Subset ptr per module
	get_val(ImapModule, AccountSubset, "name")
	module has ConfigSet
	subset has logical prefix
imap_get_val(subset, "name)

split config => subset is just a name
	get_val(ImapModule, Account->name, "name") NO
	need HE for Inheritance
if we get_val(... Mailbox->name, ...)
	need to default to M->val, A-val, N-val (initial)

on "account" need to inherit.  inherit what?  everything?
flagged for inheritance => reg_var NO
	notification Config on new Account "name"
	reg_var("name", inherit)
	"account work"
		-> notify new A
		-> Config observes
		-> Config notify new A
		=> imap inherit "work:name"
	"mailbox todo"
		-> notify new M
		-> Config observes
		-> Config notify new M
		=> imap inherit "work:todo:name"
	who concats 'work' and 'todo'?

subset knows parent
	M-sub "work:todo" -> A-sub "work" -> NULL -> plain name
	get_val(ImapModule, M-sub, "name")

how does set_val() work?
how does completion work if all vars aren't declared?

physical split can' work unless Config is part of Module API
Central Config - module owners?
module API ∀ add_inheritance("acc") or ("acc:mbox")
	=> inherit ∀ flagged config
	remove_inheritance() opposite
	list_config() -> completion purposes

set_val()
	set name = val			set name = val
	account set name = val		set acc:name = val
	mailbox set name = val		set acc:mbox:name = val

parse_set() needs to know about all the modules
	or every variable has a module ptr { set(), get() }
	set acc:mbox:name -> split out name, lookup set(a:m:name)
	can't lookup name, need to iterate ∀ modules
	inherit flag on ConfigDef -> can be dumped as help!
		separate flags for A-, M-specific inheritance
		M- implies A-

should we instantiate EVERY inherited value?
	200 items * 5 accounts => 1000 empty configs (HashElems)
	or teach "set" completion about accounts/mailboxes

Completion
	"set <tab>"
		all BASE config names
		all ACCOUNT names (complete to "acc:")
	"set acc:<tab>"
		all Account-specific config names
		all MAILBOX names (complete to "acc:mbox:")
	"set acc:mbox:<tab>"
		all Mailbox-specific config name

Dump
	":set" (only changed)
		BASE config names
		Account-specific config names
		Maibox-specific config names
	":set all" (all config)
		all BASE config names
		changed Account-specific config names
		changed Maibox-specific config names

Sorting, in alpha order
	BASE config
	Account-specific config
		Mailbox-specific config
	Account-specific config
		Mailbox-specific config

If subset doesn't contain an array of HashElem,
	then N can have one has a parent of A->sub
	ConfigSet is global or on N

bit of duplication for get_val(a:m:name)
	-> inheritance, using HashElem
	or if missing, try parent subset, then grandparent subset, etc

cs_subset_new(cs?, name, parent-sub) - makes no changes to ConfigSet
cs_subset_free(sub) needs to release all scoped variables
	needs to happen before its parent is freed
	we don't have a list any more, so HashWalk to find them (if any)

how does set_val() work with missing HashElems?
assuming only base value
	set_val(a:name)
		create(a:name), if nec, set value
	set_val(a:m:name)
		create(a:name), if nec, set inherited
		breate(a:m:name), if nec, set value
how does reset(a:name) work?
	NEVER delete (leave until subset_free())
	create(a:name) if nec, set inherited

how does reset(a:m:name) work?
	create(a:name) if nec, set inherited
	create(a:m:name), if nec, set inherited

--------------------------------------------------------------------------------

Account/Mailbox commands

how does "mailbox" command work?
can't be global, needs to be A-specific
	otherwise nested A-config and nested M-config will break

---------------------------------------------------------------------
file1.rc		file2.rc		file3.rc

account work
mailbox todo
source file2.rc
			config (work:todo:)
			account home
			config (home:)
			mailbox diy
			source file3.rc
						config (home:diy:)
						EOF
			EOF
config (work:todo:)
EOF
---------------------------------------------------------------------
convert to svg

not global
	A-stack is on N
	M-stack is on A
	N->get_current_A()
	A->get_current_M()

NO, won't work, "source" needs to dupe stack top

global stack of { A-name, M-name }?
	{acc,-} -> {acc,mbox} or {-,mbox}?
	what about mailbox apple banana?
	{acc,-}, {-,apple}, {-,banana}?
new file (source) -> dupe to last A
EOF -> kill to last A
New A -> kill to last A, add {new-A,-}
New M -> kill top M's, add {-,new-M}

change {str,str} to {int,str} NT_ACC, NT_MBOX
multiple M's -> multiple sub's -> complex cose

suggest mailbox apple source shared.rc, etc
back to {str,str}? only one A, only one M

new A -> set	{A,-}	set_account()
new M2 -> set	{A,M2}	set_mailbox()
source -> dupe top	push_top()
EOF			pop()
startup push {-,-}
	should return to this after every complete config read

--------------------------------------------------------------------------------

account work
	[options]
	mailboxes a b c
	named-mailboxes A a B b C c
	mailbox D d
		[options]

or mailbox is named synonym
	no, not quite
	named is legacy

named-mailboxes E e F f	doesn't affect following options
mailbox G g H h		affects following options
	applies to single/multiple mailboxes

mailbox [empty] or account [empty]
or mailbox new-name or account new-name, or EOF

stack of names, cf account
	except in multiple cases - comma-separated
--------------------------------------------------------------------------------

modules plus inherted Config*Set*s
subset has entire ConfigSet, flagged, with pointer to parent Set
Account.subset.ConfigSet get_val(name)
	=> lookup plain "name", if fails look at Set->parent
is ConfigSet names?  prob no need
modules would be unaware of inherited set
*NO*  we'd need 1 inherted Set per module
unless Inherited item points to parent set  NO
	if item isn't inherited we've got no info

--------------------------------------------------------------------------------

we don't instantiate all inherited values
	=> subset is empty, just name,parent
	=> NeoMutt can have a subset
	=> all config could be abstract

unaccount name|*|...
	destroy name(s), or all A
	if A->name in ConfigAccountStack, NULL then
	so we keep the stack sane on EOF
if we invalidate current A, invalidate M-stack too

--------------------------------------------------------------------------------

"account name"
"account"
"account name config"

"mailbox name"
"mailbox"
"mailbox name config"

should allow "account name mailbox name config"

account wants name, description
mailbox wants name, description

description command on in A-,M-config
name is short, used for config, default in sidebar
desc(ription) can be anything, utf-8, whitespace, etc

named-mailboxes => mailbox name  -- what about the path?
mailbox needs path, can have name, desc

disallow?
	"account name config"
	"mailbox name config"
	=> hence :account name config etc?
	=> config that you can't type in manually
unless you can
	account name<enter>
	config<enter>
	config<enter><enter>
(continuation prompt)

account name [config]	=> set name:X
mailbox name path	=> set name:name:X
mailbox name [config]
	path set path		=> mailbox name path imap://
	desc set description	=> mailbox name desc "pretty"

account takes desc command too
	mailboxes path [path] ...
	named-mailboxes name path [name path] ...
	mailbox name path imap://
extensible to other commands

deprecate named-mailboxes -> mailbox
gotcha: mailbox "name" path is one-liner
	following config isn't scoped to "name"
sloppy parsing?  allow continuation?
so these are equivalent:

	mailbox work
		path imap://
		set index_format=""

	mailbox work path imap://
		set index_format=""

doesn't apply to ':' commands
	they're one-liners

NEED path command, should add desc command
what about:
	mailbox name desc "pretty" path imap://
	each command takes exactly one param
	can we chain them?
trickier with other commands, 'set' eats all args
	account name desc pretty set index_format=""
	desc has to come first

account NAME [config]
	desc[ription]
mailbox NAME [config]
	path PATH
	desc[ription]

--------------------------------------------------------------------------------

mailboxes / named-mailboxes PATH
	sufficient to identify type and create Account
"account", "mailbox" incomplete until "path"
path -> magic for M & A, mxops
what happens when M's in an A don't have matching types?
what happens if a path is missing?
	potentially A is untyped
leave them in memory in case more config is read?
do we notify when A,M are created or when complete?
if only complete, then need big warnings after config red

--------------------------------------------------------------------------------

simple A only "account name"; config; mailboxes * n
	or named mailboxes * n
ay config of (named-)mailboxes is M-scoped
A-specific non-config would go on A-view, e.g. colours

--------------------------------------------------------------------------------

what config exists?
	N, NA, NM, NAM
what config is wanted?
	N, NA, NAM

want N
	only N.global, or by name "index_format"
	for global config, or unsupported inheritance
	NA, NAM, NM disallowed

want NA
	get_account(), subset_get("index_format")
	NM, NAM disallowed
	handles A missing, defaults to N

want NAM
	get_mailbox(), subset_get("index_format")
	all allowed
	handles M or AM missing, A missing irrelevant

want N
	get_neomutt() / N.sub, subset_get("index_format")
	for consistency

merge get_X(), get_val()?  NO can't.  don't know which A/M to use
get_val() needs (N,A,M-sub, name)
	sub might not exists (unnamed)
config many not be inherited
get_A, get_M only relevant during config read (tracker only relevant)
parse_set needs to distinguish between get_val()
	during config setup and later?
	no, just the src or A,M is diff
		get A vs param A, etc

get_var(sub,name) wrapper

how does independent ':set' work?
what about &, !, inv, no?
	where do they fit?

--------------------------------------------------------------------------------

set, completion(index_format, folder)
tests FA

set noX, acc:noX, acc:mbox:noX
set invX, acc:invX, acc:mbox:invX
unset X, acc:X, acc:mbox:X

{set,unset,reset,toggle} [acc:[mbox:]]X

set {&,?}[acc:[mbox:]]X
set [acc:[mbox:]]X?

